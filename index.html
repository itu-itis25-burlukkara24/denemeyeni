<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Ayazaƒüadan Ka√ßƒ±≈ü</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            cursor: none;
        }

        #game {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 170px;
            left: 20px;
            z-index: 2;
            pointer-events: none;
            mix-blend-mode: difference;
        }

        #minimap-container {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 5;
            pointer-events: none;
        }

        #minimap {
            border: 2px solid rgba(0, 255, 100, 0.5);
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 255, 100, 0.3);
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: transparent;
            z-index: 3;
            box-shadow: inset 0 0 150px #000;
        }

        #noise {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.08;
            pointer-events: none;
            z-index: 4;
            background-image: url('data:image/svg+xml;utf8,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="3" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)"/%3E%3C/svg%3E');
        }

        #start {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            cursor: pointer;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 3rem;
            text-shadow: 2px 0 red, -2px 0 blue;
            letter-spacing: 5px;
        }

        p {
            font-size: 1.2rem;
            opacity: 0.8;
        }

        /* Crosshair / Staff Aiming */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 6;
            pointer-events: none;
            font-size: 30px;
            color: #8800ff;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #8800ff;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.7;
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
        }
    </style>
</head>

<body>

    <div id="minimap-container">
        <canvas id="minimap" width="140" height="140"></canvas>
    </div>

    <div id="ui">
        <div>AKIL SAƒûLIƒûI: <span id="sanity-val">100%</span></div>
        <div>ANAHTARLAR: <span id="keys-val">0/3</span></div>
        <div id="msg"></div>
    </div>
    <div id="crosshair">‚ú¶</div>
    <div id="overlay"></div>
    <div id="noise"></div>

    <div id="start">
        <h1>AYAZAƒûADAN KA√áI≈û</h1>
        <p style="font-size: 1rem; color: #ff4444; margin-bottom: 15px;">M√úHFAK Sƒ∞Zƒ∞ YOK EDECEK</p>
        <p>[ BA≈ûLAMAK ƒ∞√áƒ∞N TIKLA ]</p>
        <p style="font-size: 0.8rem; color: #666;">KULAKLIK √ñNERƒ∞Lƒ∞R</p>
        <p style="font-size: 0.7rem; color: #888; margin-top: 15px;">
            üñ±Ô∏è MOUSE = Etrafa Bak<br>
            üñ±Ô∏è SOL TIK = B√ºy√º At<br>
            üñ±Ô∏è SAƒû TIK = Yakƒ±n Saldƒ±rƒ±<br>
            ‚å®Ô∏è WASD = Y√ºr√º (Strafe)<br>
            ‚å®Ô∏è E = Kapƒ±yƒ± A√ß<br>
            ‚å®Ô∏è SHIFT = Ko≈ü
        </p>
        <p style="font-size: 0.6rem; color: #555; margin-top: 10px;">3 anahtar bul ‚Üí √áƒ±kƒ±≈ü kapƒ±sƒ±na git ‚Üí E'ye bas ‚Üí
            Ka√ß!</p>
    </div>

    <canvas id="game"></canvas>

    <script>
        /**
         * ENGINE: RAYCASTING (WOLFENSTEIN 3D STYLE)
         * AUDIO: WEB AUDIO API OSCILLATORS
         * AI: A* PATHFINDING + LOS CHECK
         * MAGIC SYSTEM + MINIMAP
         */

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d', { alpha: false });
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const uiSanity = document.getElementById('sanity-val');
        const uiKeys = document.getElementById('keys-val');
        const uiMsg = document.getElementById('msg');
        const startScreen = document.getElementById('start');
        const crosshair = document.getElementById('crosshair');

        // Config
        const WIDTH = 640;
        const HEIGHT = 360; // Internal resolution for retro feel
        const FOV = Math.PI / 3;
        const BLOCK_SIZE = 64;
        const MAP_SIZE = 24; // EXPANDED MAP!
        const MAX_DEPTH = 20; // Increased render distance
        const RAYS = WIDTH / 2; // Resolution divider
        const MINIMAP_SIZE = 140; // Bigger minimap for bigger map
        const MINIMAP_SCALE = MINIMAP_SIZE / MAP_SIZE;

        let running = false;
        let audioCtx;
        let lastTime = 0;

        // Magic Staff System
        let staffCooldown = 0;
        const STAFF_COOLDOWN_TIME = 0.4;
        let spellProjectiles = [];
        let staffGlow = 0;
        let staffParticles = []; // For visual effects

        // Exit Door System
        let exitDoor = { x: 0, y: 0, active: false };
        let bloodSplatters = []; // Blood around exit
        let gameWon = false;

        // Game State
        const player = { x: 2.5, y: 2.5, dir: 0, speed: 3.5, rotSpeed: 1.5 };
        const inputKeys = { w: false, s: false, a: false, d: false, left: false, right: false, shift: false, e: false };
        const map = []; // 1: Wall, 0: Empty, 2: Key, 3: Exit Door
        let collectedKeys = 0;
        let sanity = 100;

        // SCARY ENEMIES ARRAY - MORE ENEMIES FOR BIGGER MAP!
        let enemies = [
            // Shadow Stalker - The original, enhanced with glowing eyes and tendrils
            { x: 18.5, y: 18.5, active: false, speed: 2.2, type: 'stalker', phase: 0, hp: 200, maxHp: 200, hitFlash: 0, breathPhase: 0 },
            // The Crawler - Moves erratically on walls, spider-like
            { x: 20.5, y: 5.5, active: false, speed: 3.5, type: 'crawler', phase: 0, hp: 120, maxHp: 120, hitFlash: 0, legPhase: 0 },
            // Glitch Entity - Teleports randomly, distorts vision
            { x: 5.5, y: 18.5, active: false, speed: 1.8, type: 'glitch', phase: 0, teleportTimer: 0, hp: 160, maxHp: 160, hitFlash: 0 },
            // The Watcher - Giant floating eye, freezes player when looking
            { x: 12.5, y: 12.5, active: false, speed: 1.2, type: 'watcher', phase: 0, stareTimer: 0, hp: 240, maxHp: 240, hitFlash: 0, pupilX: 0, pupilY: 0 },
            // Second Stalker for bigger map
            { x: 6.5, y: 6.5, active: false, speed: 2.0, type: 'stalker', phase: Math.PI, hp: 200, maxHp: 200, hitFlash: 0, breathPhase: 0 },
            // Second Crawler
            { x: 18.5, y: 8.5, active: false, speed: 3.2, type: 'crawler', phase: Math.PI / 2, hp: 120, maxHp: 120, hitFlash: 0, legPhase: 0 },
            // NEW ENEMY: Third Stalker (The Ambiancer)
            { x: 2.5, y: 15.5, active: false, speed: 2.4, type: 'stalker', phase: Math.PI / 3, hp: 200, maxHp: 200, hitFlash: 0, breathPhase: 0 }
        ];
        let enemy = enemies[0]; // Keep for compatibility
        let screenShake = 0;
        let glitchEffect = 0;
        let freezeTimer = 0;

        // Audio Nodes
        let ambianceNode, heartNode, screechNode, whisperNode;

        // --- INIT ---
        function init() {
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            generateMap();

            // Resize handler
            window.addEventListener('resize', () => {
                // Keep internal res fixed, stretch via CSS
            });

            document.addEventListener('keydown', e => {
                handleKey(e.key, true);

                // DIRECT E KEY CHECK for exit door
                if (e.key.toLowerCase() === 'e' && running && exitDoor.active) {
                    let distToExit = Math.sqrt(
                        Math.pow(player.x - exitDoor.x, 2) +
                        Math.pow(player.y - exitDoor.y, 2)
                    );
                    if (distToExit < 4) {
                        victory();
                    }
                }
            });
            document.addEventListener('keyup', e => handleKey(e.key, false));

            startScreen.addEventListener('click', () => {
                if (!audioCtx) initAudio();
                startScreen.classList.add('hidden');
                canvas.requestPointerLock();
                running = true;
                enemies.forEach(e => e.active = true);
                requestAnimationFrame(loop);
            });

            // MOUSE LOOK (FPS STYLE)
            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === canvas && running) {
                    player.dir += e.movementX * 0.003;
                }
            });

            // MAGIC SPELL CASTING - Left click to cast, Right click melee
            document.addEventListener('mousedown', (e) => {
                if (!running) return;
                if (e.button === 0 && staffCooldown <= 0) {
                    castSpell();
                } else if (e.button === 2 && staffCooldown <= 0) {
                    meleeAttack();
                }
            });

            // Prevent right-click context menu
            document.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        // --- SPELL CASTING SYSTEM ---
        function castSpell() {
            staffCooldown = STAFF_COOLDOWN_TIME;
            staffGlow = 1.0;

            // Create spell projectile
            const spell = {
                x: player.x,
                y: player.y,
                dir: player.dir,
                speed: 12,
                life: 3,
                damage: 25
            };
            spellProjectiles.push(spell);
            playSound('spell_cast');

            // Visual feedback
            crosshair.style.transform = 'translate(-50%, -50%) scale(1.5)';
            crosshair.style.color = '#ff00ff';
            setTimeout(() => {
                crosshair.style.transform = 'translate(-50%, -50%) scale(1)';
                crosshair.style.color = '#8800ff';
            }, 100);
        }

        // --- MELEE ATTACK SYSTEM (Right Click) ---
        function meleeAttack() {
            staffCooldown = STAFF_COOLDOWN_TIME * 0.7; // Faster than spell
            staffGlow = 1.5;
            screenShake = 5;

            // Play melee sound - deep thud
            if (audioCtx) {
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.15);
                g.gain.setValueAtTime(0.5, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
                osc.connect(g).connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            }

            // Check for enemies in melee range (in front of player)
            enemies.forEach(enemy => {
                if (!enemy.active || enemy.hp <= 0) return;

                let dx = enemy.x - player.x;
                let dy = enemy.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                // Check if enemy is close and in front
                if (dist < 2.5) {
                    let angleToEnemy = Math.atan2(dy, dx);
                    let angleDiff = angleToEnemy - player.dir;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;

                    if (Math.abs(angleDiff) < Math.PI / 3) { // 60 degree cone
                        // HIT!
                        enemy.hp -= 40; // More damage than spell
                        enemy.hitFlash = 1.5;
                        screenShake = 8;
                        playSound('enemy_scream', enemy.type);

                        if (enemy.hp <= 0) {
                            enemy.active = false;
                            playSound('enemy_death', enemy.type);
                            uiMsg.innerText = "M√úHFAK ƒ∞BNELERƒ∞ ƒ∞NDƒ∞Rƒ∞LDƒ∞!";
                            setTimeout(() => uiMsg.innerText = "", 2000);
                        } else {
                            uiMsg.innerText = "VURU≈û! -40 HP";
                            setTimeout(() => uiMsg.innerText = "", 1000);
                        }
                    }
                }
            });

            // Visual feedback - red flash
            crosshair.style.transform = 'translate(-50%, -50%) scale(2)';
            crosshair.style.color = '#ff0000';
            setTimeout(() => {
                crosshair.style.transform = 'translate(-50%, -50%) scale(1)';
                crosshair.style.color = '#8800ff';
            }, 150);
        }

        function handleKey(k, state) {
            k = k.toLowerCase();
            if (k === 'w' || k === 'arrowup') inputKeys.w = state;
            if (k === 's' || k === 'arrowdown') inputKeys.s = state;
            if (k === 'a') inputKeys.left = state;
            if (k === 'd') inputKeys.right = state;
            if (k === 'arrowleft') inputKeys.left = state;
            if (k === 'arrowright') inputKeys.right = state;
            if (k === 'shift') inputKeys.shift = state;
            if (k === 'e') inputKeys.e = state; // Interact key for exit door
        }

        // --- GENERATION ---
        function generateMap() {
            // "THE VOID ARENA" - Bigger map with rooms and corridors
            map.length = 0;

            // Start with all walls
            for (let y = 0; y < MAP_SIZE; y++) {
                let row = [];
                for (let x = 0; x < MAP_SIZE; x++) {
                    row.push(1);
                }
                map.push(row);
            }

            // Carve out rooms
            const rooms = [
                // Spawn room (top-left)
                { x: 1, y: 1, w: 5, h: 5 },
                // Key room 1 (top-right corner)
                { x: MAP_SIZE - 7, y: 1, w: 6, h: 5, hasKey: true },
                // Key room 2 (bottom-left corner)
                { x: 1, y: MAP_SIZE - 7, w: 5, h: 6, hasKey: true },
                // Key room 3 (center-right)
                { x: MAP_SIZE - 6, y: 10, w: 5, h: 5, hasKey: true },
                // Central arena
                { x: 8, y: 8, w: 8, h: 8 },
                // Exit room (bottom-right) - with blood!
                { x: MAP_SIZE - 6, y: MAP_SIZE - 6, w: 5, h: 5, isExit: true },
                // Connecting rooms
                { x: 7, y: 2, w: 4, h: 3 },
                { x: 2, y: 10, w: 4, h: 4 },
                { x: 14, y: 2, w: 3, h: 4 }
            ];

            // Carve rooms
            rooms.forEach(room => {
                for (let y = room.y; y < room.y + room.h && y < MAP_SIZE - 1; y++) {
                    for (let x = room.x; x < room.x + room.w && x < MAP_SIZE - 1; x++) {
                        map[y][x] = 0;
                    }
                }

                // Place key in room
                if (room.hasKey) {
                    let kx = room.x + Math.floor(room.w / 2);
                    let ky = room.y + Math.floor(room.h / 2);
                    map[ky][kx] = 2;
                }

                // Place exit door
                if (room.isExit) {
                    let ex = room.x + Math.floor(room.w / 2);
                    let ey = room.y + Math.floor(room.h / 2);
                    map[ey][ex] = 3; // Exit door tile
                    exitDoor.x = ex + 0.5;
                    exitDoor.y = ey + 0.5;

                    // Generate blood splatters around exit
                    for (let i = 0; i < 15; i++) {
                        bloodSplatters.push({
                            x: ex + (Math.random() - 0.5) * 4,
                            y: ey + (Math.random() - 0.5) * 4,
                            size: 0.2 + Math.random() * 0.4,
                            opacity: 0.5 + Math.random() * 0.5
                        });
                    }
                }
            });

            // Carve corridors between rooms
            const corridors = [
                // Spawn to top area
                { x1: 5, y1: 3, x2: 8, y2: 3 },
                // Top horizontal
                { x1: 10, y1: 3, x2: MAP_SIZE - 7, y2: 3 },
                // Left vertical to bottom-left
                { x1: 3, y1: 5, x2: 3, y2: MAP_SIZE - 7 },
                // Center connections
                { x1: 5, y1: 12, x2: 8, y2: 12 },
                { x1: 16, y1: 12, x2: MAP_SIZE - 6, y2: 12 },
                // Right side vertical
                { x1: MAP_SIZE - 4, y1: 5, x2: MAP_SIZE - 4, y2: 10 },
                { x1: MAP_SIZE - 4, y1: 15, x2: MAP_SIZE - 4, y2: MAP_SIZE - 6 },
                // Bottom horizontal
                { x1: 5, y1: MAP_SIZE - 4, x2: MAP_SIZE - 6, y2: MAP_SIZE - 4 },
                // More connections for variety
                { x1: 12, y1: 5, x2: 12, y2: 8 },
                { x1: 12, y1: 16, x2: 12, y2: MAP_SIZE - 4 }
            ];

            corridors.forEach(c => {
                let x = c.x1, y = c.y1;
                while (x !== c.x2 || y !== c.y2) {
                    if (x < MAP_SIZE - 1 && x > 0 && y < MAP_SIZE - 1 && y > 0) {
                        map[y][x] = 0;
                        // Make corridors 2 wide
                        if (y + 1 < MAP_SIZE - 1) map[y + 1][x] = 0;
                        if (x + 1 < MAP_SIZE - 1) map[y][x + 1] = 0;
                    }
                    if (x < c.x2) x++;
                    else if (x > c.x2) x--;
                    if (y < c.y2) y++;
                    else if (y > c.y2) y--;
                }
            });

            // Add some random pillars for cover
            for (let i = 0; i < 12; i++) {
                let px = 6 + Math.floor(Math.random() * (MAP_SIZE - 12));
                let py = 6 + Math.floor(Math.random() * (MAP_SIZE - 12));
                if (map[py][px] === 0 && map[py][px] !== 2 && map[py][px] !== 3) {
                    map[py][px] = 1;
                }
            }

            // Clear player spawn area
            map[2][2] = 0; map[2][3] = 0; map[3][2] = 0; map[3][3] = 0;
            map[1][1] = 0; map[1][2] = 0; map[2][1] = 0;

            // Place enemies FAR from player spawn (player starts at 2.5, 2.5)
            const enemySpawns = [
                { x: 20.5, y: 20.5 },  // Far corner
                { x: 21.5, y: 5.5 },   // Top right
                { x: 5.5, y: 20.5 },   // Bottom left
                { x: 15.5, y: 15.5 },  // Center-ish
                { x: 12.5, y: 8.5 },   // Mid-top
                { x: 20.5, y: 12.5 }   // Right side
            ];

            enemies.forEach((e, i) => {
                if (i < enemySpawns.length) {
                    let sp = enemySpawns[i];
                    // Ensure space is clear
                    if (map[Math.floor(sp.y)] && map[Math.floor(sp.y)][Math.floor(sp.x)] === 1) {
                        map[Math.floor(sp.y)][Math.floor(sp.x)] = 0;
                    }
                    e.x = sp.x;
                    e.y = sp.y;
                }
                e.hp = e.maxHp;
            });
        }

        // --- AUDIO SYSTEM (Procedural) ---
        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();

            // Ambiance (Low drone)
            ambianceNode = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            ambianceNode.type = 'sawtooth';
            ambianceNode.frequency.value = 50;
            gain.gain.value = 0.05;

            // Filter for drone
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 120;

            ambianceNode.connect(filter).connect(gain).connect(audioCtx.destination);
            ambianceNode.start();

            // Heartbeat logic setup
            heartNode = {
                play: () => {
                    const osc = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    osc.frequency.setValueAtTime(60, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.1);
                    g.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    osc.connect(g).connect(audioCtx.destination);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.15);
                }
            };
        }

        // --- ENGINE CORE ---
        function loop(timestamp) {
            if (!running) return;
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            update(dt);

            // Check if game ended during update
            if (!running) return;

            render();

            requestAnimationFrame(loop);
        }

        function update(dt) {
            if (gameWon) return;

            // Player Movement
            // Player Movement (WASD + Strafe)
            const moveStep = (inputKeys.shift ? player.speed * 1.5 : player.speed) * dt;

            let moveX = 0;
            let moveY = 0;

            // Forward/Back
            if (inputKeys.w) {
                moveX += Math.cos(player.dir) * moveStep;
                moveY += Math.sin(player.dir) * moveStep;
            }
            if (inputKeys.s) {
                moveX -= Math.cos(player.dir) * moveStep;
                moveY -= Math.sin(player.dir) * moveStep;
            }

            // Strafe Left/Right
            if (inputKeys.left) { // A
                moveX += Math.cos(player.dir - Math.PI / 2) * moveStep;
                moveY += Math.sin(player.dir - Math.PI / 2) * moveStep;
            }
            if (inputKeys.right) { // D
                moveX += Math.cos(player.dir + Math.PI / 2) * moveStep;
                moveY += Math.sin(player.dir + Math.PI / 2) * moveStep;
            }

            const newX = player.x + moveX;
            const newY = player.y + moveY;

            // Collision (allow walking on keys and exit door)
            if (map[Math.floor(newY)] && (map[Math.floor(newY)][Math.floor(player.x)] === 0 || map[Math.floor(newY)][Math.floor(player.x)] >= 2)) player.y = newY;
            if (map[Math.floor(player.y)] && (map[Math.floor(player.y)][Math.floor(newX)] === 0 || map[Math.floor(player.y)][Math.floor(newX)] >= 2)) player.x = newX;

            // Item Pickup
            let px = Math.floor(player.x);
            let py = Math.floor(player.y);
            if (map[py] && map[py][px] === 2) {
                map[py][px] = 0;
                collectedKeys++;
                uiKeys.innerText = `${collectedKeys}/3`;
                if (collectedKeys < 3) {
                    uiMsg.innerText = `üîë KEY ${collectedKeys}/3 ACQUIRED!`;
                } else {
                    uiMsg.innerText = "üö™ ALL KEYS! FIND THE EXIT DOOR!";
                    exitDoor.active = true;
                }
                setTimeout(() => uiMsg.innerText = "", 3000);
                playSound('pickup');
            }

            // Exit Door Interaction - E key escape
            let distToExit = Math.sqrt(
                Math.pow(player.x - exitDoor.x, 2) +
                Math.pow(player.y - exitDoor.y, 2)
            );

            // Check if near exit door
            if (distToExit < 3) {
                if (exitDoor.active) {
                    uiMsg.innerText = "üö™ [E] KAPIYI A√á VE KA√á!";
                    if (inputKeys.e) {
                        victory();
                        return;
                    }
                } else {
                    uiMsg.innerText = "ÔøΩ Kapƒ± kilitli! 3 anahtar bul.";
                }
            }

            // MULTI-ENEMY AI SYSTEM
            if (freezeTimer > 0) {
                freezeTimer -= dt;
            }

            enemies.forEach((enemy, idx) => {
                if (!enemy.active) return;

                let dx = player.x - enemy.x;
                let dy = player.y - enemy.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                enemy.phase += dt * 5;

                // Movement based on enemy type
                let moveX = 0, moveY = 0;

                if (enemy.type === 'stalker') {
                    // Shadow Stalker - Slowly follows player
                    moveX = (dx / dist) * enemy.speed * dt * 0.4;
                    moveY = (dy / dist) * enemy.speed * dt * 0.4;
                }
                else if (enemy.type === 'crawler') {
                    // Crawler - Erratic spider-like movement
                    let erratic = Math.sin(enemy.phase * 3) * 0.5;
                    moveX = (dx / dist + erratic) * enemy.speed * dt * 0.5;
                    moveY = (dy / dist + Math.cos(enemy.phase * 4) * 0.5) * enemy.speed * dt * 0.5;
                }
                else if (enemy.type === 'glitch') {
                    // Glitch Entity - Teleports randomly
                    enemy.teleportTimer += dt;
                    if (enemy.teleportTimer > 3 + Math.random() * 2) {
                        // Teleport to random valid position near player
                        let angle = Math.random() * Math.PI * 2;
                        let teleportDist = 3 + Math.random() * 4;
                        let newX = player.x + Math.cos(angle) * teleportDist;
                        let newY = player.y + Math.sin(angle) * teleportDist;
                        newX = Math.max(1, Math.min(MAP_SIZE - 2, newX));
                        newY = Math.max(1, Math.min(MAP_SIZE - 2, newY));
                        if (map[Math.floor(newY)][Math.floor(newX)] !== 1) {
                            enemy.x = newX;
                            enemy.y = newY;
                            glitchEffect = 1.0;
                            playSound('glitch');
                        }
                        enemy.teleportTimer = 0;
                    }
                    moveX = (dx / dist) * enemy.speed * dt * 0.3;
                    moveY = (dy / dist) * enemy.speed * dt * 0.3;
                }
                else if (enemy.type === 'watcher') {
                    // The Watcher - Freezes player when in view
                    let spriteAngle = Math.atan2(dy, dx) - player.dir;
                    while (spriteAngle < -Math.PI) spriteAngle += 2 * Math.PI;
                    while (spriteAngle > Math.PI) spriteAngle -= 2 * Math.PI;

                    if (Math.abs(spriteAngle) < FOV / 2 && dist < MAX_DEPTH) {
                        // Player is looking at the Watcher
                        enemy.stareTimer += dt;
                        if (enemy.stareTimer > 0.5) {
                            freezeTimer = 0.3;
                            sanity -= dt * 8;
                        }
                    } else {
                        enemy.stareTimer = 0;
                        moveX = (dx / dist) * enemy.speed * dt * 0.6;
                        moveY = (dy / dist) * enemy.speed * dt * 0.6;
                    }
                }

                // Apply movement with collision
                let ex = enemy.x + moveX;
                let ey = enemy.y + moveY;
                if (map[Math.floor(ey)][Math.floor(ex)] !== 1) {
                    if (freezeTimer <= 0 || enemy.type === 'watcher') {
                        enemy.x = ex;
                        enemy.y = ey;
                    }
                }

                // Proximity effects
                if (dist < 4) {
                    // Heartbeat based on closest enemy
                    let beatRate = Math.max(150, dist * 80);
                    if (Date.now() % Math.floor(beatRate) < 20) heartNode.play();

                    // Screen shake when very close
                    if (dist < 2) {
                        screenShake = Math.max(screenShake, (2 - dist) * 3);
                    }
                }

                // Sanity drain based on proximity
                if (dist < 3) sanity -= dt * (4 - dist) * 2;

                // Death check
                if (dist < 0.5) {
                    gameOver(enemy.type);
                }
            });

            // Decay effects
            screenShake *= 0.9;
            glitchEffect *= 0.95;
            staffGlow *= 0.9;
            staffCooldown -= dt;

            // UPDATE SPELL PROJECTILES
            spellProjectiles = spellProjectiles.filter(spell => {
                // Move spell
                spell.x += Math.cos(spell.dir) * spell.speed * dt;
                spell.y += Math.sin(spell.dir) * spell.speed * dt;
                spell.life -= dt;

                // Check wall collision
                if (spell.x < 0 || spell.x >= MAP_SIZE || spell.y < 0 || spell.y >= MAP_SIZE) {
                    return false;
                }
                if (map[Math.floor(spell.y)][Math.floor(spell.x)] === 1) {
                    return false;
                }

                // Check enemy collision
                for (let enemy of enemies) {
                    if (!enemy.active || enemy.hp <= 0) continue;

                    let dx = spell.x - enemy.x;
                    let dy = spell.y - enemy.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 0.8) {
                        // HIT! Damage enemy
                        enemy.hp -= spell.damage;
                        enemy.hitFlash = 1.0;
                        screenShake = 3;

                        // ENEMY SCREAM!
                        playSound('enemy_scream', enemy.type);

                        // Show damage message
                        uiMsg.innerText = `VURU≈û! -${spell.damage} HP`;
                        setTimeout(() => uiMsg.innerText = "", 1500);

                        // Check if enemy died
                        if (enemy.hp <= 0) {
                            enemy.active = false;
                            playSound('enemy_death', enemy.type);
                            uiMsg.innerText = "M√úHFAK ƒ∞BNELERƒ∞ ƒ∞NDƒ∞Rƒ∞LDƒ∞!";
                            setTimeout(() => uiMsg.innerText = "", 2000);
                        }

                        return false; // Remove spell
                    }
                }

                return spell.life > 0;
            });

            // Decay enemy hit flash
            enemies.forEach(enemy => {
                if (enemy.hitFlash > 0) {
                    enemy.hitFlash *= 0.85;
                }
            });

            if (sanity < 0) gameOver('insanity');
            uiSanity.innerText = Math.floor(sanity) + "%";
        }

        function render() {
            // Ceiling/Floor
            ctx.fillStyle = "#111";
            ctx.fillRect(0, 0, WIDTH, HEIGHT / 2);
            ctx.fillStyle = "#222";
            ctx.fillRect(0, HEIGHT / 2, WIDTH, HEIGHT / 2);

            // Raycasting
            for (let x = 0; x < RAYS; x++) {
                const rayAngle = (player.dir - FOV / 2.0) + (x / RAYS) * FOV;
                const eyeX = Math.cos(rayAngle);
                const eyeY = Math.sin(rayAngle);

                let distToWall = 0;
                let hitWall = false;
                let texture = 0; // 0: Wall, 1: Key

                let testX = player.x;
                let testY = player.y;

                // DDA Algorithm (Simplified)
                while (!hitWall && distToWall < MAX_DEPTH) {
                    distToWall += 0.1;
                    testX = player.x + eyeX * distToWall;
                    testY = player.y + eyeY * distToWall;

                    if (testX < 0 || testX >= MAP_SIZE || testY < 0 || testY >= MAP_SIZE) {
                        hitWall = true;
                        distToWall = MAX_DEPTH;
                    } else {
                        let block = map[Math.floor(testY)][Math.floor(testX)];
                        if (block === 1) { hitWall = true; texture = 1; }
                        else if (block === 2) {
                            // Render Key as separate sprite? No, simplified: Color change
                        }
                    }
                }

                // Fisheye fix
                let ca = player.dir - rayAngle;
                if (ca < 0) ca += 2 * Math.PI;
                if (ca > 2 * Math.PI) ca -= 2 * Math.PI;
                distToWall = distToWall * Math.cos(ca);

                // Wall Height
                const ceiling = HEIGHT / 2.0 - HEIGHT / distToWall;
                const floor = HEIGHT - ceiling;
                const wallHeight = floor - ceiling;

                // Draw Wall strip
                let color = Math.floor(255 / (distToWall * 0.8)); // Distance shading
                if (color > 255) color = 255;

                ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;

                // Key is special logic, simplistic rendering for snippet
                /* Advanced: Sprite rendering is complex for 1 file. 
                   We will indicate items via UI/HUD radar or proximity sound. */

                const w = WIDTH / RAYS;
                ctx.fillRect(x * w, ceiling, w, wallHeight);
            }

            // Apply screen shake
            if (screenShake > 0.1) {
                ctx.save();
                ctx.translate(
                    (Math.random() - 0.5) * screenShake * 5,
                    (Math.random() - 0.5) * screenShake * 5
                );
            }

            // Apply glitch effect overlay
            if (glitchEffect > 0.1) {
                ctx.fillStyle = `rgba(255, 0, 255, ${glitchEffect * 0.3})`;
                for (let i = 0; i < 10; i++) {
                    let y = Math.random() * HEIGHT;
                    let h = Math.random() * 20;
                    ctx.fillRect(0, y, WIDTH, h);
                }
            }

            // RENDER ALL SCARY ENEMIES
            enemies.forEach((enemy) => {
                if (!enemy.active) return;

                let dx = enemy.x - player.x;
                let dy = enemy.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                let spriteAngle = Math.atan2(dy, dx) - player.dir;
                while (spriteAngle < -Math.PI) spriteAngle += 2 * Math.PI;
                while (spriteAngle > Math.PI) spriteAngle -= 2 * Math.PI;

                // Is visible in FOV?
                if (Math.abs(spriteAngle) < FOV / 1.5 && dist < MAX_DEPTH && dist > 0.5) {

                    // WALL OCCLUSION CHECK - Cast ray to enemy to see if wall blocks view
                    let rayDir = Math.atan2(dy, dx);
                    let blocked = false;
                    let checkDist = 0.5;
                    while (checkDist < dist - 0.3) {
                        let checkX = player.x + Math.cos(rayDir) * checkDist;
                        let checkY = player.y + Math.sin(rayDir) * checkDist;
                        if (map[Math.floor(checkY)] && map[Math.floor(checkY)][Math.floor(checkX)] === 1) {
                            blocked = true;
                            break;
                        }
                        checkDist += 0.3;
                    }

                    if (blocked) return; // Don't render if wall blocks view
                    let screenX = (0.5 * (spriteAngle / (FOV / 2)) + 0.5) * WIDTH;
                    let spriteHeight = HEIGHT / dist;
                    let spriteWidth = spriteHeight * 0.6;
                    let pulse = Math.sin(enemy.phase) * 0.1 + 1;

                    if (enemy.type === 'stalker') {
                        // SHADOW STALKER - Dark figure with glowing red eyes and tendrils
                        // Body - Tall dark silhouette
                        ctx.fillStyle = `rgba(10, 0, 15, ${1 - dist / 12})`;
                        ctx.fillRect(screenX - spriteWidth / 2, HEIGHT / 2 - spriteHeight / 2, spriteWidth, spriteHeight * 1.2);

                        // Tendrils coming from body
                        ctx.strokeStyle = `rgba(30, 0, 40, ${1 - dist / 10})`;
                        ctx.lineWidth = 3;
                        for (let t = 0; t < 6; t++) {
                            ctx.beginPath();
                            let tx = screenX + (t - 3) * spriteWidth / 6;
                            let baseY = HEIGHT / 2 + spriteHeight / 3;
                            ctx.moveTo(tx, baseY);
                            let wave = Math.sin(enemy.phase + t) * 20;
                            ctx.quadraticCurveTo(tx + wave, baseY + spriteHeight / 2, tx + wave * 2, baseY + spriteHeight);
                            ctx.stroke();
                        }

                        // Glowing RED eyes
                        let eyeGlow = 20 + Math.sin(enemy.phase * 2) * 10;
                        ctx.shadowBlur = eyeGlow;
                        ctx.shadowColor = 'red';
                        ctx.fillStyle = `rgba(255, 0, 0, ${1 - dist / 8})`;
                        ctx.beginPath();
                        ctx.arc(screenX - spriteWidth / 5, HEIGHT / 2 - spriteHeight / 4, spriteWidth / 8 * pulse, 0, Math.PI * 2);
                        ctx.arc(screenX + spriteWidth / 5, HEIGHT / 2 - spriteHeight / 4, spriteWidth / 8 * pulse, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;

                        // Gaping mouth
                        ctx.fillStyle = `rgba(50, 0, 0, ${1 - dist / 10})`;
                        ctx.beginPath();
                        ctx.ellipse(screenX, HEIGHT / 2, spriteWidth / 4, spriteHeight / 8 * pulse, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    else if (enemy.type === 'crawler') {
                        // THE CRAWLER - Spider-like horror with multiple legs
                        let crawlOffset = Math.sin(enemy.phase * 4) * 5;

                        // Body (hunched over)
                        ctx.fillStyle = `rgba(40, 20, 30, ${1 - dist / 10})`;
                        ctx.beginPath();
                        ctx.ellipse(screenX, HEIGHT / 2 + crawlOffset, spriteWidth / 2, spriteHeight / 3, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Multiple spider legs
                        ctx.strokeStyle = `rgba(60, 30, 40, ${1 - dist / 8})`;
                        ctx.lineWidth = 4;
                        for (let leg = 0; leg < 8; leg++) {
                            ctx.beginPath();
                            let legX = screenX + (leg - 4) * spriteWidth / 8;
                            let legPhase = Math.sin(enemy.phase * 6 + leg * 0.5) * 15;
                            ctx.moveTo(legX, HEIGHT / 2 + crawlOffset);
                            ctx.lineTo(legX + legPhase, HEIGHT / 2 + spriteHeight / 2 + Math.abs(legPhase));
                            ctx.stroke();
                        }

                        // Multiple glowing eyes (spider eyes)
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = 'yellow';
                        ctx.fillStyle = `rgba(255, 200, 0, ${1 - dist / 8})`;
                        for (let eye = 0; eye < 6; eye++) {
                            ctx.beginPath();
                            let eyeX = screenX + (eye - 2.5) * spriteWidth / 10;
                            let eyeY = HEIGHT / 2 - spriteHeight / 5 + crawlOffset + (eye % 2) * 5;
                            ctx.arc(eyeX, eyeY, spriteWidth / 15, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.shadowBlur = 0;

                        // Mandibles
                        ctx.strokeStyle = `rgba(80, 0, 0, ${1 - dist / 8})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(screenX - spriteWidth / 6, HEIGHT / 2 + spriteHeight / 6 + crawlOffset);
                        ctx.lineTo(screenX - spriteWidth / 3, HEIGHT / 2 + spriteHeight / 3 + crawlOffset);
                        ctx.moveTo(screenX + spriteWidth / 6, HEIGHT / 2 + spriteHeight / 6 + crawlOffset);
                        ctx.lineTo(screenX + spriteWidth / 3, HEIGHT / 2 + spriteHeight / 3 + crawlOffset);
                        ctx.stroke();
                    }
                    else if (enemy.type === 'glitch') {
                        // GLITCH ENTITY - Distorted static humanoid
                        // Glitchy body made of static lines
                        for (let i = 0; i < 20; i++) {
                            let glitchY = HEIGHT / 2 - spriteHeight / 2 + (i / 20) * spriteHeight;
                            let glitchOffset = (Math.random() - 0.5) * 30 * (1 - dist / MAX_DEPTH);
                            let glitchWidth = spriteWidth * (0.5 + Math.random() * 0.5);

                            // RGB split effect
                            ctx.fillStyle = `rgba(255, 0, 0, ${0.5 - dist / 20})`;
                            ctx.fillRect(screenX - glitchWidth / 2 + glitchOffset - 3, glitchY, glitchWidth, spriteHeight / 20);
                            ctx.fillStyle = `rgba(0, 255, 0, ${0.5 - dist / 20})`;
                            ctx.fillRect(screenX - glitchWidth / 2 + glitchOffset, glitchY, glitchWidth, spriteHeight / 20);
                            ctx.fillStyle = `rgba(0, 0, 255, ${0.5 - dist / 20})`;
                            ctx.fillRect(screenX - glitchWidth / 2 + glitchOffset + 3, glitchY, glitchWidth, spriteHeight / 20);
                        }

                        // Static face
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.8 - dist / 10})`;
                        ctx.fillRect(screenX - spriteWidth / 4, HEIGHT / 2 - spriteHeight / 3, spriteWidth / 8, spriteHeight / 20);
                        ctx.fillRect(screenX + spriteWidth / 8, HEIGHT / 2 - spriteHeight / 3, spriteWidth / 8, spriteHeight / 20);

                        // Glitching mouth that opens
                        let mouthOpen = Math.abs(Math.sin(enemy.phase * 8)) * spriteHeight / 10;
                        ctx.fillStyle = `rgba(0, 0, 0, ${1 - dist / 8})`;
                        ctx.fillRect(screenX - spriteWidth / 6, HEIGHT / 2 - spriteHeight / 6, spriteWidth / 3, mouthOpen);
                    }
                    else if (enemy.type === 'watcher') {
                        // THE WATCHER - Giant floating bloodshot eye
                        let eyeSize = spriteWidth * 0.8 * pulse;

                        // Outer eye (white with bloodshot veins)
                        ctx.fillStyle = `rgba(240, 230, 220, ${1 - dist / 12})`;
                        ctx.beginPath();
                        ctx.ellipse(screenX, HEIGHT / 2, eyeSize, eyeSize * 0.7, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Bloodshot veins
                        ctx.strokeStyle = `rgba(200, 50, 50, ${0.7 - dist / 15})`;
                        ctx.lineWidth = 2;
                        for (let v = 0; v < 12; v++) {
                            ctx.beginPath();
                            let angle = (v / 12) * Math.PI * 2 + enemy.phase * 0.1;
                            ctx.moveTo(screenX + Math.cos(angle) * eyeSize * 0.3, HEIGHT / 2 + Math.sin(angle) * eyeSize * 0.2);
                            let wobble = Math.sin(enemy.phase + v) * 5;
                            ctx.quadraticCurveTo(
                                screenX + Math.cos(angle) * eyeSize * 0.6 + wobble,
                                HEIGHT / 2 + Math.sin(angle) * eyeSize * 0.4,
                                screenX + Math.cos(angle) * eyeSize * 0.95,
                                HEIGHT / 2 + Math.sin(angle) * eyeSize * 0.65
                            );
                            ctx.stroke();
                        }

                        // Iris (follows player - always looking at you)
                        ctx.fillStyle = `rgba(50, 100, 80, ${1 - dist / 10})`;
                        ctx.beginPath();
                        ctx.arc(screenX, HEIGHT / 2, eyeSize * 0.4, 0, Math.PI * 2);
                        ctx.fill();

                        // Pupil (shrinks when looking at player)
                        let pupilSize = enemy.stareTimer > 0.5 ? eyeSize * 0.1 : eyeSize * 0.25;
                        ctx.fillStyle = `rgba(0, 0, 0, ${1 - dist / 10})`;
                        ctx.beginPath();
                        ctx.arc(screenX, HEIGHT / 2, pupilSize, 0, Math.PI * 2);
                        ctx.fill();

                        // Eerie glow when staring
                        if (enemy.stareTimer > 0.5) {
                            ctx.shadowBlur = 30;
                            ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
                            ctx.strokeStyle = `rgba(255, 100, 100, ${0.5 + Math.sin(enemy.phase * 5) * 0.3})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.ellipse(screenX, HEIGHT / 2, eyeSize * 1.1, eyeSize * 0.8, 0, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                        }
                    }

                    // ===== HEALTH BAR above enemy =====
                    if (enemy.hp > 0 && enemy.hp < enemy.maxHp) {
                        let barWidth = spriteWidth * 0.8;
                        let barHeight = 6;
                        let barX = screenX - barWidth / 2;
                        let barY = HEIGHT / 2 - spriteHeight / 2 - 15;

                        // Background
                        ctx.fillStyle = 'rgba(50, 0, 0, 0.8)';
                        ctx.fillRect(barX, barY, barWidth, barHeight);

                        // Health fill
                        let hpPercent = enemy.hp / enemy.maxHp;
                        let hpColor = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
                        ctx.fillStyle = hpColor;
                        ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);

                        // Border
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(barX, barY, barWidth, barHeight);
                    }

                    // ===== HIT FLASH overlay =====
                    if (enemy.hitFlash > 0.1) {
                        ctx.fillStyle = `rgba(255, 100, 255, ${enemy.hitFlash * 0.5})`;
                        ctx.fillRect(screenX - spriteWidth / 2 - 5, HEIGHT / 2 - spriteHeight / 2, spriteWidth + 10, spriteHeight);
                    }
                }
            });

            // ===== RENDER SPELL PROJECTILES =====
            spellProjectiles.forEach(spell => {
                let dx = spell.x - player.x;
                let dy = spell.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                let spellAngle = Math.atan2(dy, dx) - player.dir;

                while (spellAngle < -Math.PI) spellAngle += 2 * Math.PI;
                while (spellAngle > Math.PI) spellAngle -= 2 * Math.PI;

                if (Math.abs(spellAngle) < FOV / 1.5 && dist < MAX_DEPTH && dist > 0.3) {
                    let screenX = (0.5 * (spellAngle / (FOV / 2)) + 0.5) * WIDTH;
                    let spellSize = 30 / dist;

                    // Glowing magic orb
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#ff00ff';
                    ctx.beginPath();
                    let gradient = ctx.createRadialGradient(screenX, HEIGHT / 2, 0, screenX, HEIGHT / 2, spellSize);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    gradient.addColorStop(0.3, 'rgba(200, 100, 255, 0.9)');
                    gradient.addColorStop(1, 'rgba(100, 0, 200, 0)');
                    ctx.fillStyle = gradient;
                    ctx.arc(screenX, HEIGHT / 2, spellSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });

            // ===== RENDER KEYS AS 3D FLOATING SPRITES =====
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (!map[y] || map[y][x] !== 2) continue;

                    let keyX = x + 0.5;
                    let keyY = y + 0.5;
                    let dx = keyX - player.x;
                    let dy = keyY - player.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    let keyAngle = Math.atan2(dy, dx) - player.dir;

                    while (keyAngle < -Math.PI) keyAngle += 2 * Math.PI;
                    while (keyAngle > Math.PI) keyAngle -= 2 * Math.PI;

                    if (Math.abs(keyAngle) < FOV / 1.5 && dist < MAX_DEPTH && dist > 0.5) {
                        let screenX = (0.5 * (keyAngle / (FOV / 2)) + 0.5) * WIDTH;
                        let keySize = 40 / dist;
                        let bobY = Math.sin(Date.now() / 200) * 5;

                        // Golden key glow
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#FFD700';

                        // Key body
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(screenX, HEIGHT / 2 + bobY, keySize * 0.4, 0, Math.PI * 2);
                        ctx.fill();

                        // Key shaft
                        ctx.strokeStyle = '#DAA520';
                        ctx.lineWidth = keySize * 0.15;
                        ctx.beginPath();
                        ctx.moveTo(screenX, HEIGHT / 2 + bobY + keySize * 0.3);
                        ctx.lineTo(screenX, HEIGHT / 2 + bobY + keySize);
                        ctx.stroke();

                        // Key teeth
                        ctx.beginPath();
                        ctx.moveTo(screenX, HEIGHT / 2 + bobY + keySize * 0.7);
                        ctx.lineTo(screenX + keySize * 0.2, HEIGHT / 2 + bobY + keySize * 0.7);
                        ctx.moveTo(screenX, HEIGHT / 2 + bobY + keySize * 0.9);
                        ctx.lineTo(screenX + keySize * 0.15, HEIGHT / 2 + bobY + keySize * 0.9);
                        ctx.stroke();

                        ctx.shadowBlur = 0;
                    }
                }
            }

            // ===== RENDER EXIT DOOR AS 3D SPRITE =====
            if (exitDoor.x > 0) {
                let dx = exitDoor.x - player.x;
                let dy = exitDoor.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                let doorAngle = Math.atan2(dy, dx) - player.dir;

                while (doorAngle < -Math.PI) doorAngle += 2 * Math.PI;
                while (doorAngle > Math.PI) doorAngle -= 2 * Math.PI;

                if (Math.abs(doorAngle) < FOV / 1.5 && dist < MAX_DEPTH && dist > 0.5) {
                    let screenX = (0.5 * (doorAngle / (FOV / 2)) + 0.5) * WIDTH;
                    let doorHeight = HEIGHT / dist;
                    let doorWidth = doorHeight * 0.6;

                    // Blood around door
                    ctx.fillStyle = 'rgba(100, 0, 0, 0.6)';
                    for (let i = 0; i < 8; i++) {
                        let bx = screenX + (Math.random() - 0.5) * doorWidth * 2;
                        let by = HEIGHT / 2 + (Math.random() - 0.5) * doorHeight;
                        ctx.beginPath();
                        ctx.arc(bx, by, 5 + Math.random() * 10, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Door frame
                    if (exitDoor.active) {
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#00FF00';
                        ctx.fillStyle = '#004400';
                    } else {
                        ctx.fillStyle = '#331111';
                    }
                    ctx.fillRect(screenX - doorWidth / 2, HEIGHT / 2 - doorHeight / 2, doorWidth, doorHeight);

                    // Door details
                    ctx.strokeStyle = exitDoor.active ? '#00FF88' : '#660000';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(screenX - doorWidth / 2 + 5, HEIGHT / 2 - doorHeight / 2 + 5, doorWidth - 10, doorHeight - 10);

                    // Handle
                    ctx.fillStyle = exitDoor.active ? '#FFFF00' : '#444444';
                    ctx.beginPath();
                    ctx.arc(screenX + doorWidth / 4, HEIGHT / 2, doorWidth / 10, 0, Math.PI * 2);
                    ctx.fill();

                    // "EXIT" text if active
                    if (exitDoor.active && dist < 5) {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#00FF00';
                        ctx.fillStyle = '#00FF00';
                        ctx.font = `${Math.floor(20 / dist)}px Courier`;
                        ctx.textAlign = 'center';
                        ctx.fillText('EXIT', screenX, HEIGHT / 2 - doorHeight / 2 - 10);
                        ctx.fillText('[E]', screenX, HEIGHT / 2);
                    }

                    ctx.shadowBlur = 0;
                }
            }

            // ===== RENDER MAGIC STAFF on screen =====
            renderStaff();

            if (screenShake > 0.1) {
                ctx.restore();
            }

            // ===== RENDER MINIMAP =====
            renderMinimap();
        }

        // --- RENDER MAGIC STAFF (Enhanced Aesthetic Design) ---
        function renderStaff() {
            let staffX = WIDTH - 70;
            let staffY = HEIGHT - 10;
            let glowIntensity = staffGlow * 40;
            let time = Date.now() / 1000;

            ctx.save();

            // === ORNATE WOODEN HANDLE ===
            // Main shaft with wood grain effect
            let gradient = ctx.createLinearGradient(staffX, staffY, staffX - 35, staffY - 120);
            gradient.addColorStop(0, '#8B4513');
            gradient.addColorStop(0.3, '#654321');
            gradient.addColorStop(0.5, '#8B4513');
            gradient.addColorStop(0.7, '#5D3A1A');
            gradient.addColorStop(1, '#4A2810');

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 10;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(staffX, staffY);
            ctx.quadraticCurveTo(staffX - 15, staffY - 60, staffX - 35, staffY - 120);
            ctx.stroke();

            // Wood grain details
            ctx.strokeStyle = 'rgba(40, 20, 10, 0.4)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                let offset = i * 25 + 20;
                ctx.moveTo(staffX - 3 - i * 3, staffY - offset);
                ctx.lineTo(staffX - 8 - i * 3, staffY - offset - 15);
                ctx.stroke();
            }

            // === GOLDEN RUNE BANDS ===
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 4;
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#FFD700';

            // Band 1
            ctx.beginPath();
            ctx.arc(staffX - 12, staffY - 40, 6, 0, Math.PI);
            ctx.stroke();

            // Band 2 with rune
            ctx.beginPath();
            ctx.arc(staffX - 22, staffY - 75, 7, 0, Math.PI);
            ctx.stroke();

            // Rune symbol
            ctx.font = '10px serif';
            ctx.fillStyle = '#FFD700';
            ctx.fillText('·õü', staffX - 26, staffY - 68);

            ctx.shadowBlur = 0;

            // === CRYSTAL HOLDER (Silver filigree) ===
            ctx.strokeStyle = '#C0C0C0';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(staffX - 30, staffY - 115);
            ctx.lineTo(staffX - 45, staffY - 130);
            ctx.lineTo(staffX - 35, staffY - 125);
            ctx.moveTo(staffX - 40, staffY - 115);
            ctx.lineTo(staffX - 25, staffY - 130);
            ctx.lineTo(staffX - 35, staffY - 125);
            ctx.stroke();

            // === 3D CRYSTAL ===
            let crystalX = staffX - 35;
            let crystalY = staffY - 150;
            let pulse = Math.sin(time * 3) * 0.15 + 1;

            // Crystal glow aura
            ctx.shadowBlur = 20 + glowIntensity;
            ctx.shadowColor = staffGlow > 0.1 ? '#FF00FF' : '#8800FF';

            // Crystal facets (3D effect)
            // Back facet (darker)
            ctx.fillStyle = staffGlow > 0.1 ? 'rgba(200, 50, 200, 0.9)' : 'rgba(80, 30, 120, 0.9)';
            ctx.beginPath();
            ctx.moveTo(crystalX, crystalY + 25 * pulse);
            ctx.lineTo(crystalX - 12 * pulse, crystalY);
            ctx.lineTo(crystalX, crystalY - 30 * pulse);
            ctx.lineTo(crystalX + 5, crystalY);
            ctx.closePath();
            ctx.fill();

            // Front facet (brighter)
            ctx.fillStyle = staffGlow > 0.1 ? 'rgba(255, 100, 255, 0.95)' : 'rgba(120, 60, 180, 0.95)';
            ctx.beginPath();
            ctx.moveTo(crystalX, crystalY + 25 * pulse);
            ctx.lineTo(crystalX + 5, crystalY);
            ctx.lineTo(crystalX, crystalY - 30 * pulse);
            ctx.lineTo(crystalX + 12 * pulse, crystalY);
            ctx.closePath();
            ctx.fill();

            // Highlight facet
            ctx.fillStyle = 'rgba(255, 200, 255, 0.6)';
            ctx.beginPath();
            ctx.moveTo(crystalX - 5, crystalY - 10);
            ctx.lineTo(crystalX, crystalY - 25 * pulse);
            ctx.lineTo(crystalX + 5, crystalY - 10);
            ctx.closePath();
            ctx.fill();

            // Inner core glow
            let coreGradient = ctx.createRadialGradient(crystalX, crystalY - 5, 0, crystalX, crystalY - 5, 15);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            coreGradient.addColorStop(0.5, staffGlow > 0.1 ? 'rgba(255, 150, 255, 0.6)' : 'rgba(150, 100, 200, 0.6)');
            coreGradient.addColorStop(1, 'rgba(100, 50, 150, 0)');
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(crystalX, crystalY - 5, 12 + staffGlow * 8, 0, Math.PI * 2);
            ctx.fill();

            // Sparkle effects
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            for (let i = 0; i < 3; i++) {
                let sparkleAngle = time * 2 + i * 2.1;
                let sparkleX = crystalX + Math.cos(sparkleAngle) * 8;
                let sparkleY = crystalY - 5 + Math.sin(sparkleAngle) * 8;
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.shadowBlur = 0;

            // === COOLDOWN INDICATOR (Arc style) ===
            if (staffCooldown > 0) {
                let cdPercent = staffCooldown / STAFF_COOLDOWN_TIME;
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(crystalX, crystalY - 5, 20, 0, Math.PI * 2);
                ctx.stroke();

                ctx.strokeStyle = '#FF00FF';
                ctx.beginPath();
                ctx.arc(crystalX, crystalY - 5, 20, -Math.PI / 2, -Math.PI / 2 + (1 - cdPercent) * Math.PI * 2);
                ctx.stroke();
            }

            ctx.restore();
        }

        // --- RENDER MINIMAP (Bird's eye view) ---
        function renderMinimap() {
            // Clear minimap
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);

            // Draw blood splatters first (under everything)
            bloodSplatters.forEach(blood => {
                minimapCtx.fillStyle = `rgba(150, 0, 0, ${blood.opacity * 0.6})`;
                minimapCtx.beginPath();
                minimapCtx.arc(
                    blood.x * MINIMAP_SCALE,
                    blood.y * MINIMAP_SCALE,
                    blood.size * MINIMAP_SCALE,
                    0,
                    Math.PI * 2
                );
                minimapCtx.fill();
            });

            // Draw walls and special tiles
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    let block = map[y] ? map[y][x] : 1;
                    if (block === 1) {
                        minimapCtx.fillStyle = 'rgba(100, 100, 100, 0.8)';
                    } else if (block === 2) {
                        minimapCtx.fillStyle = 'rgba(255, 215, 0, 0.9)'; // Keys are gold
                    } else if (block === 3) {
                        // Exit door - green if active, gray if not
                        if (exitDoor.active) {
                            minimapCtx.fillStyle = 'rgba(0, 255, 100, 0.9)';
                        } else {
                            minimapCtx.fillStyle = 'rgba(100, 50, 50, 0.7)';
                        }
                    } else {
                        continue; // Don't draw empty
                    }
                    minimapCtx.fillRect(
                        x * MINIMAP_SCALE,
                        y * MINIMAP_SCALE,
                        MINIMAP_SCALE,
                        MINIMAP_SCALE
                    );
                }
            }

            // (Enemies hidden on minimap for surprise factor)


            // Draw spell projectiles on minimap
            minimapCtx.fillStyle = 'rgba(200, 100, 255, 0.9)';
            spellProjectiles.forEach(spell => {
                minimapCtx.beginPath();
                minimapCtx.arc(
                    spell.x * MINIMAP_SCALE,
                    spell.y * MINIMAP_SCALE,
                    2,
                    0,
                    Math.PI * 2
                );
                minimapCtx.fill();
            });

            // Draw player on minimap
            minimapCtx.fillStyle = 'rgba(0, 255, 100, 1)';
            minimapCtx.beginPath();
            minimapCtx.arc(
                player.x * MINIMAP_SCALE,
                player.y * MINIMAP_SCALE,
                4,
                0,
                Math.PI * 2
            );
            minimapCtx.fill();

            // Draw player direction
            minimapCtx.strokeStyle = 'rgba(0, 255, 100, 0.8)';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(player.x * MINIMAP_SCALE, player.y * MINIMAP_SCALE);
            minimapCtx.lineTo(
                (player.x + Math.cos(player.dir) * 1.5) * MINIMAP_SCALE,
                (player.y + Math.sin(player.dir) * 1.5) * MINIMAP_SCALE
            );
            minimapCtx.stroke();

            // Draw FOV cone
            minimapCtx.strokeStyle = 'rgba(0, 255, 100, 0.3)';
            minimapCtx.lineWidth = 1;
            minimapCtx.beginPath();
            minimapCtx.moveTo(player.x * MINIMAP_SCALE, player.y * MINIMAP_SCALE);
            minimapCtx.lineTo(
                (player.x + Math.cos(player.dir - FOV / 2) * 3) * MINIMAP_SCALE,
                (player.y + Math.sin(player.dir - FOV / 2) * 3) * MINIMAP_SCALE
            );
            minimapCtx.moveTo(player.x * MINIMAP_SCALE, player.y * MINIMAP_SCALE);
            minimapCtx.lineTo(
                (player.x + Math.cos(player.dir + FOV / 2) * 3) * MINIMAP_SCALE,
                (player.y + Math.sin(player.dir + FOV / 2) * 3) * MINIMAP_SCALE
            );
            minimapCtx.stroke();
        }

        function playSound(type, enemyType) {
            if (!audioCtx) return;

            if (type === 'pickup') {
                // Dark metallic clang - like finding something in a horror basement
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.3);
                g.gain.setValueAtTime(0.3, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.4);
                osc.connect(g).connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.4);

                // Radiator clunk
                const osc2 = audioCtx.createOscillator();
                const g2 = audioCtx.createGain();
                osc2.type = 'square';
                osc2.frequency.setValueAtTime(30, audioCtx.currentTime);
                g2.gain.setValueAtTime(0.2, audioCtx.currentTime);
                g2.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
                osc2.connect(g2).connect(audioCtx.destination);
                osc2.start();
                osc2.stop(audioCtx.currentTime + 0.2);

            } else if (type === 'glitch') {
                // Terrifying static screech
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sawtooth';
                for (let i = 0; i < 10; i++) {
                    osc.frequency.setValueAtTime(50 + Math.random() * 200, audioCtx.currentTime + i * 0.02);
                }
                g.gain.setValueAtTime(0.4, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.connect(g).connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);

            } else if (type === 'spell_cast') {
                // Deep industrial boom
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(60, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.15);
                g.gain.setValueAtTime(0.35, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.25);
                osc.connect(g).connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.25);

            } else if (type === 'enemy_scream') {
                // TERRIFYING DEEP SCREAM - Industrial horror
                // Layer 1: Deep growl
                const osc1 = audioCtx.createOscillator();
                const g1 = audioCtx.createGain();
                osc1.type = 'sawtooth';
                osc1.frequency.setValueAtTime(40, audioCtx.currentTime);
                osc1.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.1);
                osc1.frequency.exponentialRampToValueAtTime(25, audioCtx.currentTime + 0.5);
                g1.gain.setValueAtTime(0.5, audioCtx.currentTime);
                g1.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.6);
                osc1.connect(g1).connect(audioCtx.destination);
                osc1.start();
                osc1.stop(audioCtx.currentTime + 0.6);

                // Layer 2: Radiator rattle
                const osc2 = audioCtx.createOscillator();
                const g2 = audioCtx.createGain();
                osc2.type = 'square';
                osc2.frequency.setValueAtTime(20, audioCtx.currentTime);
                for (let i = 0; i < 5; i++) {
                    osc2.frequency.setValueAtTime(15 + Math.random() * 10, audioCtx.currentTime + i * 0.08);
                }
                g2.gain.setValueAtTime(0.25, audioCtx.currentTime);
                g2.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.4);
                osc2.connect(g2).connect(audioCtx.destination);
                osc2.start();
                osc2.stop(audioCtx.currentTime + 0.4);

            } else if (type === 'enemy_death') {
                // DEATH SCREAM - Long agonizing industrial horror
                // Deep dying roar
                const osc1 = audioCtx.createOscillator();
                const g1 = audioCtx.createGain();
                osc1.type = 'sawtooth';
                osc1.frequency.setValueAtTime(60, audioCtx.currentTime);
                osc1.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 1.2);
                g1.gain.setValueAtTime(0.6, audioCtx.currentTime);
                g1.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.5);
                osc1.connect(g1).connect(audioCtx.destination);
                osc1.start();
                osc1.stop(audioCtx.currentTime + 1.5);

                // Metallic screech
                const osc2 = audioCtx.createOscillator();
                const g2 = audioCtx.createGain();
                osc2.type = 'sawtooth';
                osc2.frequency.setValueAtTime(100, audioCtx.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.8);
                g2.gain.setValueAtTime(0.35, audioCtx.currentTime);
                g2.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.0);
                osc2.connect(g2).connect(audioCtx.destination);
                osc2.start();
                osc2.stop(audioCtx.currentTime + 1.0);

                // Radiator death rattle
                for (let i = 0; i < 6; i++) {
                    const o = audioCtx.createOscillator();
                    const gg = audioCtx.createGain();
                    o.type = 'square';
                    o.frequency.setValueAtTime(15 + Math.random() * 15, audioCtx.currentTime + i * 0.15);
                    gg.gain.setValueAtTime(0.2, audioCtx.currentTime + i * 0.15);
                    gg.gain.linearRampToValueAtTime(0, audioCtx.currentTime + i * 0.15 + 0.1);
                    o.connect(gg).connect(audioCtx.destination);
                    o.start(audioCtx.currentTime + i * 0.15);
                    o.stop(audioCtx.currentTime + i * 0.15 + 0.15);
                }
            }
        }

        // --- VICTORY SCREEN ---
        function victory() {
            running = false;
            gameWon = true;
            document.exitPointerLock();

            // Victory screen
            ctx.fillStyle = "rgba(0, 20, 0, 0.95)";
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Green glow effect
            let gradient = ctx.createRadialGradient(WIDTH / 2, HEIGHT / 2, 0, WIDTH / 2, HEIGHT / 2, 200);
            gradient.addColorStop(0, 'rgba(0, 100, 50, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            ctx.fillStyle = "#00FF88";
            ctx.font = "32px Courier";
            ctx.textAlign = "center";
            ctx.shadowBlur = 20;
            ctx.shadowColor = "#00FF88";
            ctx.fillText("AYAZAƒûADAN KA√áTINIZ!", WIDTH / 2, HEIGHT / 2 - 40);

            ctx.shadowBlur = 0;
            ctx.font = "12px Courier";
            ctx.fillStyle = "#66FFAA";
            ctx.fillText("Ehabeliler elbet bir g√ºn g√∂t√ºn√ºz√º sikecektir", WIDTH / 2, HEIGHT / 2 + 10);
            ctx.fillText("ancak ≈üimdilik kurtuldunuz.", WIDTH / 2, HEIGHT / 2 + 30);

            ctx.fillStyle = "#fff";
            ctx.font = "14px Courier";
            ctx.fillText("[ TEKRAR OYNAMAK ƒ∞√áƒ∞N TIKLA ]", WIDTH / 2, HEIGHT / 2 + 70);

            if (ambianceNode) ambianceNode.stop();

            // Play victory sound
            if (audioCtx) {
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.2);
                osc.frequency.setValueAtTime(600, audioCtx.currentTime + 0.3);
                osc.frequency.exponentialRampToValueAtTime(1000, audioCtx.currentTime + 0.5);
                g.gain.setValueAtTime(0.3, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.8);
                osc.connect(g).connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.8);
            }

            setTimeout(() => {
                document.addEventListener('mousedown', () => location.reload(), { once: true });
            }, 500);
        }

        function gameOver(killer) {
            running = false;
            document.exitPointerLock();

            // Clear screen to black
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Red vignette
            let gradient = ctx.createRadialGradient(WIDTH / 2, HEIGHT / 2, 0, WIDTH / 2, HEIGHT / 2, 250);
            gradient.addColorStop(0, 'rgba(50, 0, 0, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Turkish death message
            let deathMsg = "EHABELƒ∞LERE YAKALANDINIZ";
            let subMsg = "M√ºhfak acƒ±maz.";

            if (killer === 'insanity') {
                deathMsg = "AKLIN KIRILDI";
                subMsg = "Zihin par√ßalandƒ±...";
            }

            // Glow effect
            ctx.shadowBlur = 20;
            ctx.shadowColor = "red";
            ctx.fillStyle = "#FF0000";
            ctx.font = "bold 28px Courier";
            ctx.textAlign = "center";
            ctx.fillText(deathMsg, WIDTH / 2, HEIGHT / 2);

            ctx.shadowBlur = 0;
            ctx.font = "16px Courier";
            ctx.fillStyle = "#888";
            ctx.fillText(subMsg, WIDTH / 2, HEIGHT / 2 + 35);

            ctx.fillStyle = "#fff";
            ctx.fillText("[ TEKRAR OYNAMAK ƒ∞√áƒ∞N TIKLA ]", WIDTH / 2, HEIGHT / 2 + 70);

            if (ambianceNode) ambianceNode.stop();

            // Add restart functionality
            // Use 'mousedown' on document to ensure we catch it even if pointer lock state is weird
            setTimeout(() => {
                document.addEventListener('mousedown', () => location.reload(), { once: true });
            }, 500); // Small delay to prevent instant restart if clicking while dying
        }

        init();

    </script>
</body>

</html>