<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>VOID_RUNNER_V1</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            cursor: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2;
            pointer-events: none;
            mix-blend-mode: difference;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: transparent;
            z-index: 3;
            box-shadow: inset 0 0 150px #000;
        }

        #noise {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.08;
            pointer-events: none;
            z-index: 4;
            background-image: url('data:image/svg+xml;utf8,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="3" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)"/%3E%3C/svg%3E');
        }

        #start {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            cursor: pointer;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 3rem;
            text-shadow: 2px 0 red, -2px 0 blue;
            letter-spacing: 5px;
        }

        p {
            font-size: 1.2rem;
            opacity: 0.8;
        }
    </style>
</head>

<body>

    <div id="ui">
        <div>SANITY: <span id="sanity-val">100%</span></div>
        <div>KEYS: <span id="keys-val">0/3</span></div>
        <div id="msg"></div>
    </div>
    <div id="overlay"></div>
    <div id="noise"></div>

    <div id="start">
        <h1>THE LABYRINTH</h1>
        <p>[ CLICK TO INITIALIZE ]</p>
        <p style="font-size: 0.8rem; color: #666;">HEADPHONES REQUIRED</p>
    </div>

    <canvas id="game"></canvas>

    <script>
        /**
         * ENGINE: RAYCASTING (WOLFENSTEIN 3D STYLE)
         * AUDIO: WEB AUDIO API OSCILLATORS
         * AI: A* PATHFINDING + LOS CHECK
         */

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d', { alpha: false });
        const uiSanity = document.getElementById('sanity-val');
        const uiKeys = document.getElementById('keys-val');
        const uiMsg = document.getElementById('msg');
        const startScreen = document.getElementById('start');

        // Config
        const WIDTH = 640;
        const HEIGHT = 360; // Internal resolution for retro feel
        const FOV = Math.PI / 3;
        const BLOCK_SIZE = 64;
        const MAP_SIZE = 16;
        const MAX_DEPTH = 16; // Render distance
        const RAYS = WIDTH / 2; // Resolution divider

        let running = false;
        let audioCtx;
        let lastTime = 0;

        // Game State
        const player = { x: 2.5, y: 2.5, dir: 0, speed: 3.0, rotSpeed: 2.5 };
        const keys = { w: false, s: false, a: false, d: false, left: false, right: false, shift: false };
        const map = []; // 1: Wall, 0: Empty, 2: Key, 3: Exit
        let collectedKeys = 0;
        let sanity = 100;
        // SCARY ENEMIES ARRAY
        let enemies = [
            // Shadow Stalker - The original, enhanced with glowing eyes and tendrils
            { x: 10.5, y: 10.5, active: false, speed: 2.0, type: 'stalker', phase: 0 },
            // The Crawler - Moves erratically on walls, spider-like
            { x: 13.5, y: 5.5, active: false, speed: 3.5, type: 'crawler', phase: 0 },
            // Glitch Entity - Teleports randomly, distorts vision
            { x: 5.5, y: 12.5, active: false, speed: 1.5, type: 'glitch', phase: 0, teleportTimer: 0 },
            // The Watcher - Giant floating eye, freezes player when looking
            { x: 8.5, y: 8.5, active: false, speed: 1.0, type: 'watcher', phase: 0, stareTimer: 0 }
        ];
        let enemy = enemies[0]; // Keep for compatibility
        let screenShake = 0;
        let glitchEffect = 0;
        let freezeTimer = 0;

        // Audio Nodes
        let ambianceNode, heartNode, screechNode, whisperNode;

        // --- INIT ---
        function init() {
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            generateMap();

            // Resize handler
            window.addEventListener('resize', () => {
                // Keep internal res fixed, stretch via CSS
            });

            document.addEventListener('keydown', e => handleKey(e.key, true));
            document.addEventListener('keyup', e => handleKey(e.key, false));

            startScreen.addEventListener('click', () => {
                if (!audioCtx) initAudio();
                startScreen.classList.add('hidden');
                canvas.requestPointerLock();
                running = true;
                enemies.forEach(e => e.active = true);
                requestAnimationFrame(loop);
            });
        }

        function handleKey(k, state) {
            k = k.toLowerCase();
            if (k === 'w' || k === 'arrowup') keys.w = state;
            if (k === 's' || k === 'arrowdown') keys.s = state;
            if (k === 'a') keys.left = state; // Strafe/Turn logic split handled in update
            if (k === 'd') keys.right = state;
            if (k === 'arrowleft') keys.left = state;
            if (k === 'arrowright') keys.right = state;
            if (k === 'shift') keys.shift = state;
        }

        // --- GENERATION ---
        function generateMap() {
            // Simple cellular noise or hardcoded room
            for (let y = 0; y < MAP_SIZE; y++) {
                let row = [];
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (x === 0 || x === MAP_SIZE - 1 || y === 0 || y === MAP_SIZE - 1) row.push(1);
                    else row.push(Math.random() > 0.85 ? 1 : 0);
                }
                map.push(row);
            }
            // Clear spawn
            map[2][2] = 0; map[2][3] = 0; map[3][2] = 0;
            // Place Keys
            let placed = 0;
            while (placed < 3) {
                let rx = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                let ry = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                if (map[ry][rx] === 0) { map[ry][rx] = 2; placed++; }
            }
        }

        // --- AUDIO SYSTEM (Procedural) ---
        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();

            // Ambiance (Low drone)
            ambianceNode = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            ambianceNode.type = 'sawtooth';
            ambianceNode.frequency.value = 50;
            gain.gain.value = 0.05;

            // Filter for drone
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 120;

            ambianceNode.connect(filter).connect(gain).connect(audioCtx.destination);
            ambianceNode.start();

            // Heartbeat logic setup
            heartNode = {
                play: () => {
                    const osc = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    osc.frequency.setValueAtTime(60, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.1);
                    g.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    osc.connect(g).connect(audioCtx.destination);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.15);
                }
            };
        }

        // --- ENGINE CORE ---
        function loop(timestamp) {
            if (!running) return;
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            update(dt);
            render();

            requestAnimationFrame(loop);
        }

        function update(dt) {
            // Player Movement
            const moveStep = (keys.shift ? player.speed * 1.5 : player.speed) * dt;
            const rotStep = player.rotSpeed * dt;

            if (keys.left) player.dir -= rotStep;
            if (keys.right) player.dir += rotStep;

            const newX = player.x + Math.cos(player.dir) * (keys.w ? moveStep : keys.s ? -moveStep : 0);
            const newY = player.y + Math.sin(player.dir) * (keys.w ? moveStep : keys.s ? -moveStep : 0);

            // Collision
            if (map[Math.floor(newY)][Math.floor(player.x)] === 0 || map[Math.floor(newY)][Math.floor(player.x)] >= 2) player.y = newY;
            if (map[Math.floor(player.y)][Math.floor(newX)] === 0 || map[Math.floor(player.y)][Math.floor(newX)] >= 2) player.x = newX;

            // Item Pickup
            let px = Math.floor(player.x);
            let py = Math.floor(player.y);
            if (map[py][px] === 2) {
                map[py][px] = 0;
                collectedKeys++;
                uiKeys.innerText = `${collectedKeys}/3`;
                uiMsg.innerText = "KEY ACQUIRED";
                setTimeout(() => uiMsg.innerText = "", 2000);
                playSound('pickup');
            }

            // MULTI-ENEMY AI SYSTEM
            if (freezeTimer > 0) {
                freezeTimer -= dt;
            }

            enemies.forEach((enemy, idx) => {
                if (!enemy.active) return;

                let dx = player.x - enemy.x;
                let dy = player.y - enemy.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                enemy.phase += dt * 5;

                // Movement based on enemy type
                let moveX = 0, moveY = 0;

                if (enemy.type === 'stalker') {
                    // Shadow Stalker - Slowly follows player
                    moveX = (dx / dist) * enemy.speed * dt * 0.4;
                    moveY = (dy / dist) * enemy.speed * dt * 0.4;
                }
                else if (enemy.type === 'crawler') {
                    // Crawler - Erratic spider-like movement
                    let erratic = Math.sin(enemy.phase * 3) * 0.5;
                    moveX = (dx / dist + erratic) * enemy.speed * dt * 0.5;
                    moveY = (dy / dist + Math.cos(enemy.phase * 4) * 0.5) * enemy.speed * dt * 0.5;
                }
                else if (enemy.type === 'glitch') {
                    // Glitch Entity - Teleports randomly
                    enemy.teleportTimer += dt;
                    if (enemy.teleportTimer > 3 + Math.random() * 2) {
                        // Teleport to random valid position near player
                        let angle = Math.random() * Math.PI * 2;
                        let teleportDist = 3 + Math.random() * 4;
                        let newX = player.x + Math.cos(angle) * teleportDist;
                        let newY = player.y + Math.sin(angle) * teleportDist;
                        newX = Math.max(1, Math.min(MAP_SIZE - 2, newX));
                        newY = Math.max(1, Math.min(MAP_SIZE - 2, newY));
                        if (map[Math.floor(newY)][Math.floor(newX)] !== 1) {
                            enemy.x = newX;
                            enemy.y = newY;
                            glitchEffect = 1.0;
                            playSound('glitch');
                        }
                        enemy.teleportTimer = 0;
                    }
                    moveX = (dx / dist) * enemy.speed * dt * 0.3;
                    moveY = (dy / dist) * enemy.speed * dt * 0.3;
                }
                else if (enemy.type === 'watcher') {
                    // The Watcher - Freezes player when in view
                    let spriteAngle = Math.atan2(dy, dx) - player.dir;
                    while (spriteAngle < -Math.PI) spriteAngle += 2 * Math.PI;
                    while (spriteAngle > Math.PI) spriteAngle -= 2 * Math.PI;

                    if (Math.abs(spriteAngle) < FOV / 2 && dist < MAX_DEPTH) {
                        // Player is looking at the Watcher
                        enemy.stareTimer += dt;
                        if (enemy.stareTimer > 0.5) {
                            freezeTimer = 0.3;
                            sanity -= dt * 8;
                        }
                    } else {
                        enemy.stareTimer = 0;
                        moveX = (dx / dist) * enemy.speed * dt * 0.6;
                        moveY = (dy / dist) * enemy.speed * dt * 0.6;
                    }
                }

                // Apply movement with collision
                let ex = enemy.x + moveX;
                let ey = enemy.y + moveY;
                if (map[Math.floor(ey)][Math.floor(ex)] !== 1) {
                    if (freezeTimer <= 0 || enemy.type === 'watcher') {
                        enemy.x = ex;
                        enemy.y = ey;
                    }
                }

                // Proximity effects
                if (dist < 4) {
                    // Heartbeat based on closest enemy
                    let beatRate = Math.max(150, dist * 80);
                    if (Date.now() % Math.floor(beatRate) < 20) heartNode.play();

                    // Screen shake when very close
                    if (dist < 2) {
                        screenShake = Math.max(screenShake, (2 - dist) * 3);
                    }
                }

                // Sanity drain based on proximity
                if (dist < 3) sanity -= dt * (4 - dist) * 2;

                // Death check
                if (dist < 0.5) {
                    gameOver(enemy.type);
                }
            });

            // Decay effects
            screenShake *= 0.9;
            glitchEffect *= 0.95;

            if (sanity < 0) gameOver('insanity');
            uiSanity.innerText = Math.floor(sanity) + "%";
        }

        function render() {
            // Ceiling/Floor
            ctx.fillStyle = "#111";
            ctx.fillRect(0, 0, WIDTH, HEIGHT / 2);
            ctx.fillStyle = "#222";
            ctx.fillRect(0, HEIGHT / 2, WIDTH, HEIGHT / 2);

            // Raycasting
            for (let x = 0; x < RAYS; x++) {
                const rayAngle = (player.dir - FOV / 2.0) + (x / RAYS) * FOV;
                const eyeX = Math.cos(rayAngle);
                const eyeY = Math.sin(rayAngle);

                let distToWall = 0;
                let hitWall = false;
                let texture = 0; // 0: Wall, 1: Key

                let testX = player.x;
                let testY = player.y;

                // DDA Algorithm (Simplified)
                while (!hitWall && distToWall < MAX_DEPTH) {
                    distToWall += 0.1;
                    testX = player.x + eyeX * distToWall;
                    testY = player.y + eyeY * distToWall;

                    if (testX < 0 || testX >= MAP_SIZE || testY < 0 || testY >= MAP_SIZE) {
                        hitWall = true;
                        distToWall = MAX_DEPTH;
                    } else {
                        let block = map[Math.floor(testY)][Math.floor(testX)];
                        if (block === 1) { hitWall = true; texture = 1; }
                        else if (block === 2) {
                            // Render Key as separate sprite? No, simplified: Color change
                        }
                    }
                }

                // Fisheye fix
                let ca = player.dir - rayAngle;
                if (ca < 0) ca += 2 * Math.PI;
                if (ca > 2 * Math.PI) ca -= 2 * Math.PI;
                distToWall = distToWall * Math.cos(ca);

                // Wall Height
                const ceiling = HEIGHT / 2.0 - HEIGHT / distToWall;
                const floor = HEIGHT - ceiling;
                const wallHeight = floor - ceiling;

                // Draw Wall strip
                let color = Math.floor(255 / (distToWall * 0.8)); // Distance shading
                if (color > 255) color = 255;

                ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;

                // Key is special logic, simplistic rendering for snippet
                // Check for items
                /* Advanced: Sprite rendering is complex for 1 file. 
                   We will indicate items via UI/HUD radar or proximity sound. */

                const w = WIDTH / RAYS;
                ctx.fillRect(x * w, ceiling, w, wallHeight);
            }

            // Apply screen shake
            if (screenShake > 0.1) {
                ctx.save();
                ctx.translate(
                    (Math.random() - 0.5) * screenShake * 5,
                    (Math.random() - 0.5) * screenShake * 5
                );
            }

            // Apply glitch effect overlay
            if (glitchEffect > 0.1) {
                ctx.fillStyle = `rgba(255, 0, 255, ${glitchEffect * 0.3})`;
                for (let i = 0; i < 10; i++) {
                    let y = Math.random() * HEIGHT;
                    let h = Math.random() * 20;
                    ctx.fillRect(0, y, WIDTH, h);
                }
            }

            // RENDER ALL SCARY ENEMIES
            enemies.forEach((enemy) => {
                if (!enemy.active) return;

                let dx = enemy.x - player.x;
                let dy = enemy.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                let spriteAngle = Math.atan2(dy, dx) - player.dir;
                while (spriteAngle < -Math.PI) spriteAngle += 2 * Math.PI;
                while (spriteAngle > Math.PI) spriteAngle -= 2 * Math.PI;

                // Is visible in FOV?
                if (Math.abs(spriteAngle) < FOV / 1.5 && dist < MAX_DEPTH && dist > 0.5) {
                    let screenX = (0.5 * (spriteAngle / (FOV / 2)) + 0.5) * WIDTH;
                    let spriteHeight = HEIGHT / dist;
                    let spriteWidth = spriteHeight * 0.6;
                    let pulse = Math.sin(enemy.phase) * 0.1 + 1;

                    if (enemy.type === 'stalker') {
                        // SHADOW STALKER - Dark figure with glowing red eyes and tendrils
                        // Body - Tall dark silhouette
                        ctx.fillStyle = `rgba(10, 0, 15, ${1 - dist / 12})`;
                        ctx.fillRect(screenX - spriteWidth / 2, HEIGHT / 2 - spriteHeight / 2, spriteWidth, spriteHeight * 1.2);

                        // Tendrils coming from body
                        ctx.strokeStyle = `rgba(30, 0, 40, ${1 - dist / 10})`;
                        ctx.lineWidth = 3;
                        for (let t = 0; t < 6; t++) {
                            ctx.beginPath();
                            let tx = screenX + (t - 3) * spriteWidth / 6;
                            let baseY = HEIGHT / 2 + spriteHeight / 3;
                            ctx.moveTo(tx, baseY);
                            let wave = Math.sin(enemy.phase + t) * 20;
                            ctx.quadraticCurveTo(tx + wave, baseY + spriteHeight / 2, tx + wave * 2, baseY + spriteHeight);
                            ctx.stroke();
                        }

                        // Glowing RED eyes
                        let eyeGlow = 20 + Math.sin(enemy.phase * 2) * 10;
                        ctx.shadowBlur = eyeGlow;
                        ctx.shadowColor = 'red';
                        ctx.fillStyle = `rgba(255, 0, 0, ${1 - dist / 8})`;
                        ctx.beginPath();
                        ctx.arc(screenX - spriteWidth / 5, HEIGHT / 2 - spriteHeight / 4, spriteWidth / 8 * pulse, 0, Math.PI * 2);
                        ctx.arc(screenX + spriteWidth / 5, HEIGHT / 2 - spriteHeight / 4, spriteWidth / 8 * pulse, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;

                        // Gaping mouth
                        ctx.fillStyle = `rgba(50, 0, 0, ${1 - dist / 10})`;
                        ctx.beginPath();
                        ctx.ellipse(screenX, HEIGHT / 2, spriteWidth / 4, spriteHeight / 8 * pulse, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    else if (enemy.type === 'crawler') {
                        // THE CRAWLER - Spider-like horror with multiple legs
                        let crawlOffset = Math.sin(enemy.phase * 4) * 5;

                        // Body (hunched over)
                        ctx.fillStyle = `rgba(40, 20, 30, ${1 - dist / 10})`;
                        ctx.beginPath();
                        ctx.ellipse(screenX, HEIGHT / 2 + crawlOffset, spriteWidth / 2, spriteHeight / 3, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Multiple spider legs
                        ctx.strokeStyle = `rgba(60, 30, 40, ${1 - dist / 8})`;
                        ctx.lineWidth = 4;
                        for (let leg = 0; leg < 8; leg++) {
                            ctx.beginPath();
                            let legX = screenX + (leg - 4) * spriteWidth / 8;
                            let legPhase = Math.sin(enemy.phase * 6 + leg * 0.5) * 15;
                            ctx.moveTo(legX, HEIGHT / 2 + crawlOffset);
                            ctx.lineTo(legX + legPhase, HEIGHT / 2 + spriteHeight / 2 + Math.abs(legPhase));
                            ctx.stroke();
                        }

                        // Multiple glowing eyes (spider eyes)
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = 'yellow';
                        ctx.fillStyle = `rgba(255, 200, 0, ${1 - dist / 8})`;
                        for (let eye = 0; eye < 6; eye++) {
                            ctx.beginPath();
                            let eyeX = screenX + (eye - 2.5) * spriteWidth / 10;
                            let eyeY = HEIGHT / 2 - spriteHeight / 5 + crawlOffset + (eye % 2) * 5;
                            ctx.arc(eyeX, eyeY, spriteWidth / 15, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.shadowBlur = 0;

                        // Mandibles
                        ctx.strokeStyle = `rgba(80, 0, 0, ${1 - dist / 8})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(screenX - spriteWidth / 6, HEIGHT / 2 + spriteHeight / 6 + crawlOffset);
                        ctx.lineTo(screenX - spriteWidth / 3, HEIGHT / 2 + spriteHeight / 3 + crawlOffset);
                        ctx.moveTo(screenX + spriteWidth / 6, HEIGHT / 2 + spriteHeight / 6 + crawlOffset);
                        ctx.lineTo(screenX + spriteWidth / 3, HEIGHT / 2 + spriteHeight / 3 + crawlOffset);
                        ctx.stroke();
                    }
                    else if (enemy.type === 'glitch') {
                        // GLITCH ENTITY - Distorted static humanoid
                        // Glitchy body made of static lines
                        for (let i = 0; i < 20; i++) {
                            let glitchY = HEIGHT / 2 - spriteHeight / 2 + (i / 20) * spriteHeight;
                            let glitchOffset = (Math.random() - 0.5) * 30 * (1 - dist / MAX_DEPTH);
                            let glitchWidth = spriteWidth * (0.5 + Math.random() * 0.5);

                            // RGB split effect
                            ctx.fillStyle = `rgba(255, 0, 0, ${0.5 - dist / 20})`;
                            ctx.fillRect(screenX - glitchWidth / 2 + glitchOffset - 3, glitchY, glitchWidth, spriteHeight / 20);
                            ctx.fillStyle = `rgba(0, 255, 0, ${0.5 - dist / 20})`;
                            ctx.fillRect(screenX - glitchWidth / 2 + glitchOffset, glitchY, glitchWidth, spriteHeight / 20);
                            ctx.fillStyle = `rgba(0, 0, 255, ${0.5 - dist / 20})`;
                            ctx.fillRect(screenX - glitchWidth / 2 + glitchOffset + 3, glitchY, glitchWidth, spriteHeight / 20);
                        }

                        // Static face
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.8 - dist / 10})`;
                        ctx.fillRect(screenX - spriteWidth / 4, HEIGHT / 2 - spriteHeight / 3, spriteWidth / 8, spriteHeight / 20);
                        ctx.fillRect(screenX + spriteWidth / 8, HEIGHT / 2 - spriteHeight / 3, spriteWidth / 8, spriteHeight / 20);

                        // Glitching mouth that opens
                        let mouthOpen = Math.abs(Math.sin(enemy.phase * 8)) * spriteHeight / 10;
                        ctx.fillStyle = `rgba(0, 0, 0, ${1 - dist / 8})`;
                        ctx.fillRect(screenX - spriteWidth / 6, HEIGHT / 2 - spriteHeight / 6, spriteWidth / 3, mouthOpen);
                    }
                    else if (enemy.type === 'watcher') {
                        // THE WATCHER - Giant floating bloodshot eye
                        let eyeSize = spriteWidth * 0.8 * pulse;

                        // Outer eye (white with bloodshot veins)
                        ctx.fillStyle = `rgba(240, 230, 220, ${1 - dist / 12})`;
                        ctx.beginPath();
                        ctx.ellipse(screenX, HEIGHT / 2, eyeSize, eyeSize * 0.7, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Bloodshot veins
                        ctx.strokeStyle = `rgba(200, 50, 50, ${0.7 - dist / 15})`;
                        ctx.lineWidth = 2;
                        for (let v = 0; v < 12; v++) {
                            ctx.beginPath();
                            let angle = (v / 12) * Math.PI * 2 + enemy.phase * 0.1;
                            ctx.moveTo(screenX + Math.cos(angle) * eyeSize * 0.3, HEIGHT / 2 + Math.sin(angle) * eyeSize * 0.2);
                            let wobble = Math.sin(enemy.phase + v) * 5;
                            ctx.quadraticCurveTo(
                                screenX + Math.cos(angle) * eyeSize * 0.6 + wobble,
                                HEIGHT / 2 + Math.sin(angle) * eyeSize * 0.4,
                                screenX + Math.cos(angle) * eyeSize * 0.95,
                                HEIGHT / 2 + Math.sin(angle) * eyeSize * 0.65
                            );
                            ctx.stroke();
                        }

                        // Iris (follows player - always looking at you)
                        ctx.fillStyle = `rgba(50, 100, 80, ${1 - dist / 10})`;
                        ctx.beginPath();
                        ctx.arc(screenX, HEIGHT / 2, eyeSize * 0.4, 0, Math.PI * 2);
                        ctx.fill();

                        // Pupil (shrinks when looking at player)
                        let pupilSize = enemy.stareTimer > 0.5 ? eyeSize * 0.1 : eyeSize * 0.25;
                        ctx.fillStyle = `rgba(0, 0, 0, ${1 - dist / 10})`;
                        ctx.beginPath();
                        ctx.arc(screenX, HEIGHT / 2, pupilSize, 0, Math.PI * 2);
                        ctx.fill();

                        // Eerie glow when staring
                        if (enemy.stareTimer > 0.5) {
                            ctx.shadowBlur = 30;
                            ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
                            ctx.strokeStyle = `rgba(255, 100, 100, ${0.5 + Math.sin(enemy.phase * 5) * 0.3})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.ellipse(screenX, HEIGHT / 2, eyeSize * 1.1, eyeSize * 0.8, 0, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                        }
                    }
                }
            });

            if (screenShake > 0.1) {
                ctx.restore();
            }
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.connect(g).connect(audioCtx.destination);

            if (type === 'pickup') {
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
                g.gain.setValueAtTime(0.1, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            } else if (type === 'glitch') {
                // Creepy glitch teleport sound
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(2000, audioCtx.currentTime + 0.05);
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
                g.gain.setValueAtTime(0.3, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.15);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            }
        }

        function gameOver(killer) {
            running = false;
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Different death messages based on what killed you
            let deathMsg = "TERMINATED";
            let subMsg = "";
            ctx.fillStyle = "red";

            if (killer === 'stalker') {
                deathMsg = "CONSUMED";
                subMsg = "The shadows claimed you...";
            } else if (killer === 'crawler') {
                deathMsg = "DEVOURED";
                subMsg = "You felt every leg...";
            } else if (killer === 'glitch') {
                deathMsg = "ERR0R_404";
                subMsg = "Reality collapsed...";
                ctx.fillStyle = "#0f0";
            } else if (killer === 'watcher') {
                deathMsg = "WITNESSED";
                subMsg = "You should not have looked...";
                ctx.fillStyle = "#ff6666";
            } else if (killer === 'insanity') {
                deathMsg = "BROKEN";
                subMsg = "Your mind shattered...";
                ctx.fillStyle = "#8800ff";
            }

            ctx.font = "40px Courier";
            ctx.textAlign = "center";
            ctx.fillText(deathMsg, WIDTH / 2, HEIGHT / 2);
            ctx.font = "16px Courier";
            ctx.fillStyle = "#666";
            ctx.fillText(subMsg, WIDTH / 2, HEIGHT / 2 + 30);
            ctx.fillText("[ CLICK TO RESTART ]", WIDTH / 2, HEIGHT / 2 + 60);

            ambianceNode.stop();

            // Add restart functionality
            canvas.addEventListener('click', () => location.reload(), { once: true });
        }

        init();

    </script>
</body>

</html>