<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>AyazaÄŸadan KaÃ§Ä±ÅŸ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
        }

        /* Cursor only hidden during gameplay, visible in menus */
        body.gameplay-mode {
            cursor: none;
        }

        #game {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 170px;
            left: 20px;
            z-index: 2;
            pointer-events: none;
            mix-blend-mode: difference;
        }

        #minimap-container {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 5;
            pointer-events: none;
        }

        #minimap {
            border: 2px solid rgba(0, 255, 100, 0.5);
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 255, 100, 0.3);
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: transparent;
            z-index: 3;
            box-shadow: inset 0 0 150px #000;
        }

        #noise {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.08;
            pointer-events: none;
            z-index: 4;
            background-image: url('data:image/svg+xml;utf8,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="3" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)"/%3E%3C/svg%3E');
        }

        #start {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            cursor: pointer;
            /* Creepy pixelated background */
            background: rgba(0, 0, 0, 0.92);
            padding: 50px 80px;
            border: 3px solid #330000;
            box-shadow:
                0 0 60px rgba(80, 0, 0, 0.5),
                inset 0 0 100px rgba(30, 0, 0, 0.8),
                0 0 3px #550000;
            image-rendering: pixelated;
            min-width: 450px;
        }

        #start::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('data:image/svg+xml;utf8,%3Csvg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noise"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noise)" opacity="0.08"/%3E%3C/svg%3E');
            pointer-events: none;
            z-index: -1;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 3rem;
            text-shadow: 3px 0 #ff0000, -3px 0 #0000ff, 0 0 20px rgba(255, 0, 0, 0.5);
            letter-spacing: 8px;
            font-weight: bold;
            text-transform: uppercase;
            animation: glitchTitle 3s infinite;
            image-rendering: pixelated;
            margin-bottom: 10px;
        }

        @keyframes glitchTitle {

            0%,
            90%,
            100% {
                transform: translate(0, 0);
            }

            92% {
                transform: translate(-3px, 1px);
                text-shadow: 5px 0 #ff0000, -5px 0 #0000ff;
            }

            94% {
                transform: translate(3px, -1px);
                text-shadow: -3px 0 #ff0000, 3px 0 #0000ff;
            }

            96% {
                transform: translate(-2px, 0);
            }
        }

        p {
            font-size: 1.2rem;
            opacity: 0.8;
        }

        /* Crosshair / Staff Aiming */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 6;
            pointer-events: none;
            font-size: 30px;
            color: #8800ff;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #8800ff;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.7;
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
        }

        /* Stamina Bar */
        #stamina-container {
            position: absolute;
            top: 250px;
            left: 20px;
            z-index: 5;
            pointer-events: none;
        }

        #stamina-bar {
            width: 120px;
            height: 8px;
            background: rgba(50, 50, 50, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
        }

        #stamina-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #88ff00);
            transition: width 0.1s ease-out;
        }

        #stamina-label {
            font-size: 10px;
            color: #aaa;
            margin-bottom: 2px;
        }

        .exhausted #stamina-fill {
            background: linear-gradient(90deg, #ff0000, #ff4400) !important;
        }

        /* ===== NEW MENU SYSTEM - CREEPY PIXELATED ===== */
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 30px 0;
        }

        .menu-btn {
            background: rgba(20, 5, 5, 0.95);
            border: 3px solid #550000;
            color: #ff6666;
            padding: 18px 50px;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 4px;
            image-rendering: pixelated;
            box-shadow: 0 0 15px rgba(80, 0, 0, 0.6), inset 0 0 30px rgba(30, 0, 0, 0.5);
            text-shadow: 2px 0 #ff0000, -2px 0 #0000ff, 0 0 10px rgba(255, 0, 0, 0.4);
            animation: buttonGlitch 4s infinite;
        }

        @keyframes buttonGlitch {

            0%,
            95%,
            100% {
                transform: translate(0, 0);
            }

            96% {
                transform: translate(-2px, 1px);
            }

            97% {
                transform: translate(2px, -1px);
            }

            98% {
                transform: translate(-1px, 0);
            }
        }

        .menu-btn:hover {
            background: rgba(80, 0, 0, 0.95);
            border-color: #aa0000;
            color: #ffffff;
            box-shadow: 0 0 30px rgba(150, 0, 0, 0.7), inset 0 0 40px rgba(50, 0, 0, 0.6);
            transform: scale(1.03);
            text-shadow: 3px 0 #ff0000, -3px 0 #0000ff, 0 0 20px rgba(255, 0, 0, 0.7);
        }

        .menu-btn.primary {
            background: linear-gradient(135deg, #330000, #550000);
            border-color: #aa0000;
            font-size: 1.5rem;
            padding: 22px 60px;
            color: #ff4444;
            animation: primaryPulse 2s infinite, buttonGlitch 3s infinite;
            text-shadow: 3px 0 #ff0000, -3px 0 #0000ff, 0 0 15px rgba(255, 0, 0, 0.6);
        }

        @keyframes primaryPulse {

            0%,
            100% {
                box-shadow: 0 0 15px rgba(200, 0, 0, 0.5), inset 0 0 30px rgba(50, 0, 0, 0.5);
            }

            50% {
                box-shadow: 0 0 35px rgba(200, 0, 0, 0.8), inset 0 0 50px rgba(80, 0, 0, 0.6);
            }
        }

        .menu-btn.primary:hover {
            background: linear-gradient(135deg, #550000, #880000);
        }

        .submenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 11;
            background: rgba(5, 0, 0, 0.97);
            padding: 40px 60px;
            border: 3px solid #550000;
            border-radius: 0px;
            box-shadow:
                0 0 60px rgba(80, 0, 0, 0.6),
                inset 0 0 80px rgba(20, 0, 0, 0.9);
            min-width: 450px;
            cursor: pointer;
            image-rendering: pixelated;
        }

        .submenu::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('data:image/svg+xml;utf8,%3Csvg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noise"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noise)" opacity="0.08"/%3E%3C/svg%3E');
            pointer-events: none;
            z-index: -1;
        }

        .submenu h2 {
            color: #cc3333;
            font-size: 1.8rem;
            margin-bottom: 25px;
            text-shadow: 3px 0 #ff0000, -3px 0 #0000ff, 0 0 15px rgba(255, 0, 0, 0.6);
            letter-spacing: 5px;
            text-transform: uppercase;
            animation: glitchTitle 3s infinite;
        }

        .diff-btn {
            display: block;
            width: 100%;
            margin: 12px 0;
            padding: 16px 25px;
            background: rgba(30, 10, 10, 0.95);
            border: 2px solid #440000;
            color: #cc8888;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 2px;
            text-shadow: 1px 0 #330000, -1px 0 #000033;
        }

        .diff-btn:hover {
            background: rgba(60, 20, 20, 0.95);
            border-color: #880000;
            color: #ffaaaa;
            text-shadow: 2px 0 #ff0000, -2px 0 #0000ff;
        }

        .diff-btn.selected {
            background: rgba(100, 0, 0, 0.9);
            border-color: #ff0000;
            color: #fff;
            text-shadow: 2px 0 #ff0000, -2px 0 #0000ff, 0 0 10px rgba(255, 0, 0, 0.5);
        }

        .diff-btn[data-diff="easy"]:hover {
            border-color: #00ff00;
        }

        .diff-btn[data-diff="normal"]:hover {
            border-color: #ffaa00;
        }

        .diff-btn[data-diff="hard"]:hover {
            border-color: #ff0000;
        }

        .back-btn {
            margin-top: 25px;
            padding: 14px 40px;
            background: rgba(20, 10, 10, 0.9);
            border: 2px solid #550000;
            color: #aa6666;
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 2px;
            text-shadow: 1px 0 #330000, -1px 0 #000033;
        }

        .back-btn:hover {
            border-color: #aa0000;
            color: #ffaaaa;
            text-shadow: 2px 0 #ff0000, -2px 0 #0000ff;
        }

        .controls-list {
            text-align: left;
            line-height: 2.2;
            color: #cc9999;
            font-size: 1.1rem;
            margin: 20px 0;
            letter-spacing: 1px;
            text-shadow: 1px 0 #330000, -1px 0 #000033;
        }

        .goal-text {
            color: #00ff88;
            font-size: 1rem;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 80, 40, 0.3);
            border: 1px solid #00aa44;
            text-shadow: 0 0 10px rgba(0, 255, 100, 0.5);
            letter-spacing: 1px;
        }

        .scores-section {
            text-align: left;
            margin: 15px 0;
        }

        .scores-section h3 {
            color: #ff6644;
            font-size: 1.2rem;
            margin: 20px 0 10px 0;
            border-bottom: 2px solid #550000;
            padding-bottom: 8px;
            text-shadow: 2px 0 #ff0000, -2px 0 #0000ff;
            letter-spacing: 2px;
        }

        .scores-section p {
            color: #aa8888;
            font-size: 1rem;
            margin: 5px 0;
            letter-spacing: 1px;
        }

        .scores-section .no-score {
            color: #665555;
            font-style: italic;
        }

        .hint-text {
            font-size: 0.7rem;
            color: #553333;
            margin-top: 12px;
            letter-spacing: 1px;
            text-shadow: 1px 0 #330000, -1px 0 #000033;
        }

        /* Volume Slider */
        .volume-control {
            margin: 15px 0;
            padding: 10px;
            border-top: 1px solid #330000;
        }

        .volume-control label {
            display: block;
            color: #886666;
            font-size: 0.75rem;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .volume-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #220000;
            border: 1px solid #440000;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #880000;
            border: 2px solid #aa3333;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #880000;
            border: 2px solid #aa3333;
            cursor: pointer;
        }

        .volume-val {
            color: #aa5555;
            font-size: 0.75rem;
            margin-top: 5px;
        }

        /* Staff Selection Grid */
        .staff-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px 0;
            padding: 10px;
        }

        .staff-card {
            background: rgba(30, 10, 10, 0.95);
            border: 2px solid #440000;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .staff-card:hover {
            background: rgba(60, 20, 20, 0.95);
            border-color: #880000;
            transform: scale(1.05);
        }

        .staff-card.selected {
            background: rgba(100, 0, 0, 0.9);
            border-color: #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }

        .staff-preview {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #330000;
        }

        .staff-card span {
            color: #cc8888;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .staff-card.selected span {
            color: #ffffff;
        }
    </style>
</head>

<body>

    <div id="minimap-container">
        <canvas id="minimap" width="140" height="140"></canvas>
    </div>

    <div id="ui">
        <div>AKIL SAÄžLIÄžI: <span id="sanity-val">100%</span></div>
        <div>ANAHTARLAR: <span id="keys-val">0/3</span></div>
        <div id="msg"></div>
        <div style="margin-top: 5px;">DAYANIKLILIK: <span id="stamina-val">100%</span></div>
    </div>
    <div id="crosshair">âœ¦</div>
    <div id="overlay"></div>
    <div id="noise"></div>

    <div id="start">
        <h1>AYAZAÄžADAN KAÃ‡IÅž</h1>
        <p
            style="font-size: 0.85rem; color: #882222; margin-bottom: 5px; letter-spacing: 2px; text-shadow: 1px 0 #ff0000, -1px 0 #0000ff;">
            MÃœHFAK SÄ°ZÄ° YOK EDECEK</p>

        <div class="menu-buttons">
            <button id="btn-start" class="menu-btn primary">KAMPÃœSE GÄ°R</button>
            <button id="btn-difficulty" class="menu-btn">ZORLUK SEVÄ°YESÄ°</button>
            <button id="btn-staff" class="menu-btn">ASA SEÃ‡</button>
            <button id="btn-controls" class="menu-btn">KONTROLLER</button>
            <button id="btn-scores" class="menu-btn">EN Ä°YÄ° KAÃ‡IÅž SÃœRELERÄ°N</button>
        </div>

        <p class="hint-text">KULAKLIK Ã–NERÄ°LÄ°R</p>
    </div>

    <!-- Zorluk MenÃ¼sÃ¼ -->
    <div id="difficulty-menu" class="submenu hidden">
        <h2>ZORLUK SEVÄ°YESÄ°</h2>
        <button class="diff-btn" data-diff="easy">KOLAY - NORMAL EHABECÄ°LER</button>
        <button class="diff-btn selected" data-diff="normal">ORTA - WEÄ°RD EHABECÄ°LER</button>
        <button class="diff-btn" data-diff="hard">ZOR - ASOSYAL PÄ°Ã‡LER</button>
        <p style="color: #998877; font-size: 0.9rem; margin-top: 12px;">SeÃ§ili: <span id="current-diff"
                style="color: #ddaa88;">ORTA</span></p>

        <div class="volume-control">
            <label>SES SEVÄ°YESÄ°: <span id="volume-val">70%</span></label>
            <input type="range" id="volume-slider" class="volume-slider" min="0" max="100" value="70">
        </div>

        <div style="margin-top: 15px; padding-top: 12px; border-top: 1px solid #330000;">
            <p style="color: #aa7766; font-size: 0.95rem; margin-bottom: 10px; font-style: italic;">
                EÄŸer ehabecileri
                yenemeyecek kadar ezikseniz minimapÄ± buradan aÃ§abilirsiniz...</p><label
                style="color: #ccaa99; font-size: 1rem; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 10px;"><input
                    type="checkbox" id="minimap-toggle" style="width: 20px; height: 20px; cursor: pointer;">
                MÄ°NÄ°MAP GÃ–STER
            </label>
        </div>

        <button id="diff-back" class="back-btn">GERÄ°</button>
    </div>

    <!-- Kontroller MenÃ¼sÃ¼ -->
    <div id="controls-menu" class="submenu hidden">
        <h2>KONTROLLER</h2>
        <div class="controls-list">
            MOUSE = ETRAFA BAK<br>
            SOL TIK = BÃœYÃœ AT<br>
            SAÄž TIK = YAKIN SALDIRI<br>
            WASD = YÃœRÃœ<br>
            E = KAPIYI AÃ‡<br>
            SHIFT = HIZLI KOÅž<br>
            SPACE = OYUNU DURDUR
        </div>
        <div class="goal-text">3 ANAHTAR BUL â†’ Ã‡IKIÅž KAPISINA GÄ°T â†’ E'YE BAS â†’ KAMPÃœSTEN KURTUL</div>
        <button id="controls-back" class="back-btn">GERÄ°</button>
    </div>

    <!-- Skor Tablosu MenÃ¼sÃ¼ -->
    <div id="scores-menu" class="submenu hidden">
        <h2>EN Ä°YÄ° KAÃ‡IÅž SÃœRELERÄ°N</h2>
        <div id="scores-list">
            <!-- JavaScript ile doldurulacak -->
        </div>
        <button id="scores-back" class="back-btn">GERÄ°</button>
    </div>

    <!-- Asa SeÃ§im MenÃ¼sÃ¼ -->
    <div id="staff-menu" class="submenu hidden">
        <h2>ASA SEÃ‡</h2>
        <div class="staff-grid">
            <div class="staff-card selected" data-staff="classic">
                <canvas class="staff-preview" id="preview-classic" width="80" height="80"></canvas>
                <span>KLASÄ°K</span>
            </div>
            <div class="staff-card" data-staff="electric">
                <canvas class="staff-preview" id="preview-electric" width="80" height="80"></canvas>
                <span>ELEKTRÄ°K</span>
            </div>
            <div class="staff-card" data-staff="paper">
                <canvas class="staff-preview" id="preview-paper" width="80" height="80"></canvas>
                <span>PEÃ‡ETE</span>
            </div>
            <div class="staff-card" data-staff="electronic">
                <canvas class="staff-preview" id="preview-electronic" width="80" height="80"></canvas>
                <span>TRANSÄ°STÃ–R</span>
            </div>
        </div>
        <button id="staff-back" class="back-btn">GERÄ°</button>
    </div>

    <canvas id="game"></canvas>

    <script>
        /**
         * ENGINE: RAYCASTING (WOLFENSTEIN 3D STYLE)
         * AUDIO: WEB AUDIO API OSCILLATORS
         * AI: A* PATHFINDING + LOS CHECK
         * MAGIC SYSTEM + MINIMAP
         */

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d', { alpha: false });
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const uiSanity = document.getElementById('sanity-val');
        const uiKeys = document.getElementById('keys-val');
        const uiMsg = document.getElementById('msg');
        const startScreen = document.getElementById('start');
        const crosshair = document.getElementById('crosshair');

        // Config
        const WIDTH = 640;
        const HEIGHT = 360; // Internal resolution for retro feel
        const FOV = Math.PI / 3;
        const BLOCK_SIZE = 64;
        const MAP_SIZE = 24; // EXPANDED MAP!
        const MAX_DEPTH = 20; // Increased render distance
        const RAYS = WIDTH / 2; // Resolution divider
        const MINIMAP_SIZE = 140; // Bigger minimap for bigger map
        const MINIMAP_SCALE = MINIMAP_SIZE / MAP_SIZE;

        let running = false;
        let audioCtx;
        let lastTime = 0;

        // Magic Staff System
        let staffCooldown = 0;
        const STAFF_COOLDOWN_TIME = 0.4;
        let spellProjectiles = [];
        let staffGlow = 0;
        let staffParticles = []; // For visual effects

        // Exit Door System
        let exitDoor = { x: 0, y: 0, active: false };
        let bloodSplatters = []; // Blood around exit
        let gameWon = false;

        // Game State
        const player = { x: 2.5, y: 2.5, dir: 0, speed: 2.5, rotSpeed: 1.5 };
        const inputKeys = { w: false, s: false, a: false, d: false, left: false, right: false, shift: false, e: false };
        const map = []; // 1: Wall, 0: Empty, 2: Key, 3: Exit Door
        let collectedKeys = 0;
        let sanity = 100;

        // SCARY ENEMIES ARRAY - MIXED HORROR CREATURES!
        let enemies = [
            // Shadow Stalker - Dark figure with glowing eyes
            { x: 18.5, y: 18.5, active: false, speed: 2.2, type: 'stalker', phase: 0, hp: 200, maxHp: 200, hitFlash: 0, breathPhase: 0 },
            // Spider - 8-legged creature that shoots webs
            { x: 20.5, y: 5.5, active: false, speed: 3.5, type: 'spider', phase: 0, hp: 120, maxHp: 120, hitFlash: 0, legPhase: 0, webCooldown: 0 },
            // Glitch Entity - Teleports randomly, distorts vision
            { x: 5.5, y: 18.5, active: false, speed: 1.8, type: 'glitch', phase: 0, teleportTimer: 0, hp: 160, maxHp: 160, hitFlash: 0 },
            // The Watcher - Giant floating eye, freezes player when looking
            { x: 12.5, y: 12.5, active: false, speed: 1.2, type: 'watcher', phase: 0, stareTimer: 0, hp: 240, maxHp: 240, hitFlash: 0, pupilX: 0, pupilY: 0 },
            // Second Stalker
            { x: 6.5, y: 6.5, active: false, speed: 2.0, type: 'stalker', phase: Math.PI, hp: 200, maxHp: 200, hitFlash: 0, breathPhase: 0 },
            // Second Spider
            { x: 18.5, y: 8.5, active: false, speed: 3.2, type: 'spider', phase: Math.PI / 2, hp: 120, maxHp: 120, hitFlash: 0, legPhase: 0, webCooldown: 0 }
        ];
        let enemy = enemies[0]; // Keep for compatibility
        let screenShake = 0;
        let glitchEffect = 0;
        let freezeTimer = 0;

        // Audio Nodes
        let ambianceNode, heartNode, screechNode, whisperNode;

        // === STAMINA SYSTEM ===
        let stamina = 100;
        const maxStamina = 100;
        const staminaDrainRate = 30; // Per second when sprinting
        const staminaRegenRate = 15; // Per second when not sprinting
        let isExhausted = false; // Can't sprint when exhausted
        const exhaustedThreshold = 30; // Must recover to this % before sprinting again
        const uiStamina = document.getElementById('stamina-val');

        // === SAW TRAP SYSTEM ===
        let sawTraps = [];

        // === STICKY GROUND (Map tile 5) ===
        // Will be placed in generateMap()

        // === PAUSE SYSTEM ===
        let isPaused = false;

        // === DIFFICULTY SYSTEM ===
        let difficulty = 'normal'; // 'easy', 'normal', 'hard'
        const difficultySettings = {
            easy: { enemySpeedMult: 0.7, damageMult: 0.5, staminaDrainMult: 0.7, sawDamageMult: 0.5, playerSpeedMult: 1.05 },
            normal: { enemySpeedMult: 1.0, damageMult: 1.0, staminaDrainMult: 1.0, sawDamageMult: 1.0, playerSpeedMult: 1.0 },
            hard: { enemySpeedMult: 1.4, damageMult: 1.5, staminaDrainMult: 1.3, sawDamageMult: 1.5, playerSpeedMult: 0.95 }
        };

        // === SCORE SYSTEM ===
        let gameStartTime = 0;

        // === DYNAMIC MUSIC SYSTEM ===
        let musicIntensity = 0; // 0-1
        let staticNoiseGain = null;
        let staticNoiseNode = null;

        // === BLACKOUT SYSTEM ===
        let isBlackout = false;
        let blackoutTimer = 0;
        let blackoutDuration = 0;
        let nextBlackoutIn = 60 + Math.random() * 60; // 60-120 seconds

        // === SPIDER WEB SYSTEM ===
        let spiderWebs = []; // { x, y, radius, lifetime }

        // === MINIMAP TOGGLE ===
        let showMinimap = false; // VarsayÄ±lan kapalÄ±

        // === VOLUME CONTROL ===
        let masterVolume = 0.7; // 0-1

        // === STAFF CUSTOMIZATION ===
        let currentStaffType = localStorage.getItem('ayazaga_staff') || 'classic'; // 'classic', 'electric', 'paper', 'electronic'
        const staffNames = {
            classic: 'KLASÄ°K MOR ASA',
            electric: 'ELEKTRÄ°K KABLOSU âš¡',
            paper: 'TUVALET KAÄžIDI ðŸ§»',
            electronic: 'ELEKTRONÄ°K PARÃ‡A ðŸ”Œ'
        };

        // --- INIT ---
        function init() {
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            generateMap();

            // Resize handler
            window.addEventListener('resize', () => {
                // Keep internal res fixed, stretch via CSS
            });

            document.addEventListener('keydown', e => {
                handleKey(e.key, true);

                // DIRECT E KEY CHECK for exit door
                if (e.key.toLowerCase() === 'e' && running && exitDoor.active) {
                    let distToExit = Math.sqrt(
                        Math.pow(player.x - exitDoor.x, 2) +
                        Math.pow(player.y - exitDoor.y, 2)
                    );
                    if (distToExit < 4) {
                        victory();
                    }
                }
            });
            document.addEventListener('keyup', e => handleKey(e.key, false));

            // ===== NEW MENU SYSTEM =====
            const difficultyMenu = document.getElementById('difficulty-menu');
            const controlsMenu = document.getElementById('controls-menu');
            const scoresMenu = document.getElementById('scores-menu');

            // Start Game Button
            document.getElementById('btn-start').addEventListener('click', (e) => {
                e.stopPropagation();
                startGame();
            });

            // Difficulty Menu
            document.getElementById('btn-difficulty').addEventListener('click', (e) => {
                e.stopPropagation();
                startScreen.classList.add('hidden');
                difficultyMenu.classList.remove('hidden');
            });

            document.querySelectorAll('.diff-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    difficulty = btn.dataset.diff;
                    const diffNames = { easy: 'KOLAY', normal: 'ORTA', hard: 'ZOR' };
                    document.getElementById('current-diff').textContent = diffNames[difficulty];
                });
            });

            document.getElementById('diff-back').addEventListener('click', (e) => {
                e.stopPropagation();
                difficultyMenu.classList.add('hidden');
                startScreen.classList.remove('hidden');
            });

            // Minimap Toggle - varsayÄ±lan kapalÄ±
            document.getElementById('minimap-container').style.display = 'none';
            document.getElementById('minimap-toggle').addEventListener('change', (e) => {
                showMinimap = e.target.checked;
                document.getElementById('minimap-container').style.display = showMinimap ? 'block' : 'none';
            });

            // Controls Menu
            document.getElementById('btn-controls').addEventListener('click', (e) => {
                e.stopPropagation();
                startScreen.classList.add('hidden');
                controlsMenu.classList.remove('hidden');
            });

            document.getElementById('controls-back').addEventListener('click', (e) => {
                e.stopPropagation();
                controlsMenu.classList.add('hidden');
                startScreen.classList.remove('hidden');
            });

            // Scores Menu
            document.getElementById('btn-scores').addEventListener('click', (e) => {
                e.stopPropagation();
                startScreen.classList.add('hidden');
                scoresMenu.classList.remove('hidden');
                showScores();
            });

            document.getElementById('scores-back').addEventListener('click', (e) => {
                e.stopPropagation();
                scoresMenu.classList.add('hidden');
                startScreen.classList.remove('hidden');
            });

            // Volume Slider
            document.getElementById('volume-slider').addEventListener('input', (e) => {
                masterVolume = e.target.value / 100;
                document.getElementById('volume-val').textContent = e.target.value + '%';
                // Update master gain if audio context exists
                if (masterGainNode) {
                    masterGainNode.gain.setTargetAtTime(masterVolume, audioCtx.currentTime, 0.1);
                }
            });

            // Staff Menu
            const staffMenu = document.getElementById('staff-menu');
            document.getElementById('btn-staff').addEventListener('click', (e) => {
                e.stopPropagation();
                startScreen.classList.add('hidden');
                staffMenu.classList.remove('hidden');
                // Update selected card based on saved staff
                document.querySelectorAll('.staff-card').forEach(c => {
                    c.classList.remove('selected');
                    if (c.dataset.staff === currentStaffType) c.classList.add('selected');
                });
                // Draw staff previews
                drawAllStaffPreviews();
            });

            // Helper to update crosshair color based on staff
            function updateCrosshairForStaff(type) {
                const colors = {
                    classic: '#ff00ff',
                    electric: '#ffff00',
                    paper: '#ffffff',
                    electronic: '#00ff00'
                };
                crosshair.style.color = colors[type] || colors.classic;
            }

            document.querySelectorAll('.staff-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('.staff-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    currentStaffType = card.dataset.staff;
                    localStorage.setItem('ayazaga_staff', currentStaffType);
                    updateCrosshairForStaff(currentStaffType);
                    document.getElementById('current-staff').textContent = staffNames[currentStaffType];
                });
            });

            // Set initial crosshair color
            updateCrosshairForStaff(currentStaffType);

            document.getElementById('staff-back').addEventListener('click', (e) => {
                e.stopPropagation();
                staffMenu.classList.add('hidden');
                startScreen.classList.remove('hidden');
            });

            // MOUSE LOOK (FPS STYLE)
            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === canvas && running) {
                    player.dir += e.movementX * 0.003;
                }
            });

            // MAGIC SPELL CASTING - Left click to cast, Right click melee
            document.addEventListener('mousedown', (e) => {
                if (!running) return;
                if (e.button === 0 && staffCooldown <= 0) {
                    castSpell();
                } else if (e.button === 2 && staffCooldown <= 0) {
                    meleeAttack();
                }
            });

            // Prevent right-click context menu
            document.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        // === START GAME FUNCTION ===
        function startGame() {
            if (!audioCtx) initAudio();
            startScreen.classList.add('hidden');
            document.body.classList.add('gameplay-mode'); // Hide cursor during gameplay

            // Pointer lock with error handling for file:// protocol
            try {
                if (canvas.requestPointerLock) {
                    canvas.requestPointerLock().catch(() => {
                        // Ignore pointer lock errors on file:// protocol
                        console.log('Pointer lock not available, using fallback mouse control');
                    });
                }
            } catch (e) {
                // Fallback for browsers that don't return a promise
            }
            running = true;
            gameStartTime = Date.now();

            // Apply difficulty-based player speed
            player.speed = 2.5 * difficultySettings[difficulty].playerSpeedMult;

            // Kolay modda 1 Ã¶rÃ¼mcek deaktif
            if (difficulty === 'easy') {
                let spiders = enemies.filter(e => e.type === 'spider');
                if (spiders.length > 0) {
                    spiders[spiders.length - 1].active = false; // Son Ã¶rÃ¼mceÄŸi kapat
                    enemies.filter(e => e.type !== 'spider' || e !== spiders[spiders.length - 1]).forEach(e => e.active = true);
                } else {
                    enemies.forEach(e => e.active = true);
                }
            } else {
                enemies.forEach(e => e.active = true);
            }

            requestAnimationFrame(loop);
        }

        // === SCORE FUNCTIONS ===
        function saveScore(time) {
            let key = `ayazaga_scores_${difficulty}`;
            let scores = JSON.parse(localStorage.getItem(key) || '[]');

            scores.push({
                time: time,
                date: new Date().toLocaleDateString('tr-TR')
            });

            // Keep top 3
            scores.sort((a, b) => a.time - b.time);
            scores = scores.slice(0, 3);

            localStorage.setItem(key, JSON.stringify(scores));
        }

        function showScores() {
            let scoresDiv = document.getElementById('scores-list');
            scoresDiv.innerHTML = '';

            ['easy', 'normal', 'hard'].forEach(diff => {
                let key = `ayazaga_scores_${diff}`;
                let scores = JSON.parse(localStorage.getItem(key) || '[]');

                let diffName = diff === 'easy' ? 'KOLAY - NORMAL EHABECÄ°LER' : diff === 'normal' ? 'ORTA - WEÄ°RD EHABECÄ°LER' : 'ZOR - ASOSYAL PÄ°Ã‡LER';
                let html = `<div class="scores-section"><h3>${diffName}</h3>`;

                if (scores.length === 0) {
                    html += '<p class="no-score">HENÃœZ KAYIT YOK...</p>';
                } else {
                    scores.slice(0, 3).forEach((s, i) => {
                        let mins = Math.floor(s.time / 60);
                        let secs = Math.floor(s.time % 60);
                        let medal = i === 0 ? '1.' : i === 1 ? '2.' : '3.';
                        html += `<p>${medal} ${mins}:${secs.toString().padStart(2, '0')} - ${s.date}</p>`;
                    });
                }
                html += '</div>';
                scoresDiv.innerHTML += html;
            });
        }

        // --- SPELL CASTING SYSTEM ---
        function castSpell() {
            staffCooldown = STAFF_COOLDOWN_TIME;
            staffGlow = 1.0;

            // Asa tipine gÃ¶re renk ve efekt ayarlarÄ±
            const spellColors = {
                classic: { primary: '#ff00ff', secondary: '#8800ff' },
                electric: { primary: '#ffff00', secondary: '#ffaa00' },
                paper: { primary: '#ffffff', secondary: '#dddddd' },
                electronic: { primary: '#00ff00', secondary: '#00aa00' }
            };
            const colors = spellColors[currentStaffType] || spellColors.classic;

            // Play sound based on staff
            if (currentStaffType === 'electronic') {
                // Electronic beep/glitch sound
                if (audioCtx) {
                    const osc = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                    osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.2);
                    g.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
                    osc.connect(g).connect(audioCtx.destination);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                }
            } else {
                playSound('spell_cast');
            }

            // Create spell projectile with staff type
            const spell = {
                x: player.x,
                y: player.y,
                dir: player.dir,
                speed: 12,
                life: 3,
                damage: 25,
                staffType: currentStaffType
            };
            spellProjectiles.push(spell);

            // Visual feedback based on staff type
            crosshair.style.transform = 'translate(-50%, -50%) scale(1.5)';
            crosshair.style.color = colors.primary;
            setTimeout(() => {
                crosshair.style.transform = 'translate(-50%, -50%) scale(1)';
                crosshair.style.color = colors.secondary;
            }, 100);
        }

        // --- MELEE ATTACK SYSTEM (Right Click) ---
        function meleeAttack() {
            staffCooldown = STAFF_COOLDOWN_TIME * 0.7; // Faster than spell
            staffGlow = 1.5;
            screenShake = 5;

            // Play melee sound - deep thud
            if (audioCtx) {
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.15);
                g.gain.setValueAtTime(0.5, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
                osc.connect(g).connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            }

            // Check for enemies in melee range (in front of player)
            enemies.forEach(enemy => {
                if (!enemy.active || enemy.hp <= 0) return;

                let dx = enemy.x - player.x;
                let dy = enemy.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                // Check if enemy is close and in front
                if (dist < 2.5) {
                    let angleToEnemy = Math.atan2(dy, dx);
                    let angleDiff = angleToEnemy - player.dir;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;

                    if (Math.abs(angleDiff) < Math.PI / 3) { // 60 degree cone
                        // HIT!
                        enemy.hp -= 40; // More damage than spell
                        enemy.hitFlash = 1.5;
                        screenShake = 8;
                        playSound('enemy_scream', enemy.type);

                        if (enemy.hp <= 0) {
                            enemy.active = false;
                            playSound('enemy_death', enemy.type);
                            uiMsg.innerText = "MÃœHFAK Ä°BNELERÄ° Ä°NDÄ°RÄ°LDÄ°!";
                            setTimeout(() => uiMsg.innerText = "", 2000);
                        } else {
                            uiMsg.innerText = "VURUÅž! -40 HP";
                            setTimeout(() => uiMsg.innerText = "", 1000);
                        }
                    }
                }
            });

            // Visual feedback - red flash
            crosshair.style.transform = 'translate(-50%, -50%) scale(2)';
            crosshair.style.color = '#ff0000';
            setTimeout(() => {
                crosshair.style.transform = 'translate(-50%, -50%) scale(1)';
                crosshair.style.color = '#8800ff';
            }, 150);
        }

        function handleKey(k, state) {
            k = k.toLowerCase();
            if (k === 'w' || k === 'arrowup') inputKeys.w = state;
            if (k === 's' || k === 'arrowdown') inputKeys.s = state;
            if (k === 'a') inputKeys.left = state;
            if (k === 'd') inputKeys.right = state;
            if (k === 'arrowleft') inputKeys.left = state;
            if (k === 'arrowright') inputKeys.right = state;
            if (k === 'shift') inputKeys.shift = state;
            if (k === 'e') inputKeys.e = state; // Interact key for exit door

            // PAUSE TOGGLE with SPACE (only on key down)
            if (k === ' ' && state === true) {
                isPaused = !isPaused;
            }
        }

        // --- GENERATION ---
        function generateMap() {
            // "THE VOID ARENA" - Bigger map with rooms and corridors
            map.length = 0;

            // Start with all walls
            for (let y = 0; y < MAP_SIZE; y++) {
                let row = [];
                for (let x = 0; x < MAP_SIZE; x++) {
                    row.push(1);
                }
                map.push(row);
            }

            // Carve out rooms
            const rooms = [
                // Spawn room (top-left)
                { x: 1, y: 1, w: 5, h: 5 },
                // Key room 1 (top-right corner)
                { x: MAP_SIZE - 7, y: 1, w: 6, h: 5, hasKey: true },
                // Key room 2 (bottom-left corner)
                { x: 1, y: MAP_SIZE - 7, w: 5, h: 6, hasKey: true },
                // Key room 3 (center-right)
                { x: MAP_SIZE - 6, y: 10, w: 5, h: 5, hasKey: true },
                // Central arena
                { x: 8, y: 8, w: 8, h: 8 },
                // Exit room (bottom-right) - with blood!
                { x: MAP_SIZE - 6, y: MAP_SIZE - 6, w: 5, h: 5, isExit: true },
                // Connecting rooms
                { x: 7, y: 2, w: 4, h: 3 },
                { x: 2, y: 10, w: 4, h: 4 },
                { x: 14, y: 2, w: 3, h: 4 }
            ];

            // Carve rooms
            rooms.forEach(room => {
                for (let y = room.y; y < room.y + room.h && y < MAP_SIZE - 1; y++) {
                    for (let x = room.x; x < room.x + room.w && x < MAP_SIZE - 1; x++) {
                        map[y][x] = 0;
                    }
                }

                // Place key in room
                if (room.hasKey) {
                    let kx = room.x + Math.floor(room.w / 2);
                    let ky = room.y + Math.floor(room.h / 2);
                    map[ky][kx] = 2;
                }

                // Place exit door
                if (room.isExit) {
                    let ex = room.x + Math.floor(room.w / 2);
                    let ey = room.y + Math.floor(room.h / 2);
                    map[ey][ex] = 3; // Exit door tile
                    exitDoor.x = ex + 0.5;
                    exitDoor.y = ey + 0.5;

                    // Generate blood splatters around exit
                    for (let i = 0; i < 15; i++) {
                        bloodSplatters.push({
                            x: ex + (Math.random() - 0.5) * 4,
                            y: ey + (Math.random() - 0.5) * 4,
                            size: 0.2 + Math.random() * 0.4,
                            opacity: 0.5 + Math.random() * 0.5
                        });
                    }
                }
            });

            // Carve corridors between rooms
            const corridors = [
                // Spawn to top area
                { x1: 5, y1: 3, x2: 8, y2: 3 },
                // Top horizontal
                { x1: 10, y1: 3, x2: MAP_SIZE - 7, y2: 3 },
                // Left vertical to bottom-left
                { x1: 3, y1: 5, x2: 3, y2: MAP_SIZE - 7 },
                // Center connections
                { x1: 5, y1: 12, x2: 8, y2: 12 },
                { x1: 16, y1: 12, x2: MAP_SIZE - 6, y2: 12 },
                // Right side vertical
                { x1: MAP_SIZE - 4, y1: 5, x2: MAP_SIZE - 4, y2: 10 },
                { x1: MAP_SIZE - 4, y1: 15, x2: MAP_SIZE - 4, y2: MAP_SIZE - 6 },
                // Bottom horizontal
                { x1: 5, y1: MAP_SIZE - 4, x2: MAP_SIZE - 6, y2: MAP_SIZE - 4 },
                // More connections for variety
                { x1: 12, y1: 5, x2: 12, y2: 8 },
                { x1: 12, y1: 16, x2: 12, y2: MAP_SIZE - 4 }
            ];

            corridors.forEach(c => {
                let x = c.x1, y = c.y1;
                while (x !== c.x2 || y !== c.y2) {
                    if (x < MAP_SIZE - 1 && x > 0 && y < MAP_SIZE - 1 && y > 0) {
                        map[y][x] = 0;
                        // Make corridors 2 wide
                        if (y + 1 < MAP_SIZE - 1) map[y + 1][x] = 0;
                        if (x + 1 < MAP_SIZE - 1) map[y][x + 1] = 0;
                    }
                    if (x < c.x2) x++;
                    else if (x > c.x2) x--;
                    if (y < c.y2) y++;
                    else if (y > c.y2) y--;
                }
            });

            // Add some random pillars for cover
            for (let i = 0; i < 12; i++) {
                let px = 6 + Math.floor(Math.random() * (MAP_SIZE - 12));
                let py = 6 + Math.floor(Math.random() * (MAP_SIZE - 12));
                if (map[py][px] === 0 && map[py][px] !== 2 && map[py][px] !== 3) {
                    map[py][px] = 1;
                }
            }

            // Clear player spawn area
            map[2][2] = 0; map[2][3] = 0; map[3][2] = 0; map[3][3] = 0;
            map[1][1] = 0; map[1][2] = 0; map[2][1] = 0;

            // Place enemies FAR from player spawn (player starts at 2.5, 2.5)
            const enemySpawns = [
                { x: 20.5, y: 20.5 },  // Far corner
                { x: 21.5, y: 5.5 },   // Top right
                { x: 5.5, y: 20.5 },   // Bottom left
                { x: 15.5, y: 15.5 },  // Center-ish
                { x: 12.5, y: 8.5 },   // Mid-top
                { x: 20.5, y: 12.5 }   // Right side
            ];

            enemies.forEach((e, i) => {
                if (i < enemySpawns.length) {
                    let sp = enemySpawns[i];
                    // Ensure space is clear
                    if (map[Math.floor(sp.y)] && map[Math.floor(sp.y)][Math.floor(sp.x)] === 1) {
                        map[Math.floor(sp.y)][Math.floor(sp.x)] = 0;
                    }
                    e.x = sp.x;
                    e.y = sp.y;
                }
                e.hp = e.maxHp;
            });

            // === GENERATE SAW TRAPS ===
            sawTraps = [
                // Corridor saws - moving back and forth
                { x: 9.5, y: 3.5, startX: 8.5, startY: 3.5, endX: 11.5, endY: 3.5, speed: 2.5, phase: 0, damage: 35 },
                { x: 3.5, y: 12.5, startX: 3.5, startY: 10.5, endX: 3.5, endY: 14.5, speed: 2.0, phase: Math.PI, damage: 35 },
                { x: 12.5, y: 12.5, startX: 10.5, startY: 12.5, endX: 14.5, endY: 12.5, speed: 3.0, phase: 0, damage: 40 },
                { x: 20.5, y: 15.5, startX: 20.5, startY: 14.5, endX: 20.5, endY: 17.5, speed: 2.2, phase: Math.PI / 2, damage: 35 }
            ];

            // === PLACE STICKY GROUND (Map tile 5) ===
            // Place in some corridor sections and room corners
            const stickySpots = [
                { x: 8, y: 3 }, { x: 9, y: 3 },
                { x: 3, y: 11 }, { x: 3, y: 12 },
                { x: 14, y: 12 }, { x: 15, y: 12 },
                { x: 19, y: 19 }, { x: 19, y: 20 }, { x: 20, y: 19 },
                { x: 5, y: 19 }, { x: 5, y: 20 },
                { x: 11, y: 17 }, { x: 12, y: 17 }, { x: 13, y: 17 }
            ];

            stickySpots.forEach(spot => {
                if (map[spot.y] && map[spot.y][spot.x] === 0) {
                    map[spot.y][spot.x] = 5; // Sticky ground tile
                }
            });
        }

        // --- AUDIO SYSTEM (Procedural) ---
        let masterGainNode = null; // Master volume control

        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();

            // Master gain node for volume control
            masterGainNode = audioCtx.createGain();
            masterGainNode.gain.value = masterVolume;
            masterGainNode.connect(audioCtx.destination);

            // Ambiance (Low drone)
            ambianceNode = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            ambianceNode.type = 'sawtooth';
            ambianceNode.frequency.value = 50;
            gain.gain.value = 0.05;

            // Filter for drone
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 120;

            ambianceNode.connect(filter).connect(gain).connect(masterGainNode);
            ambianceNode.start();

            // Heartbeat logic setup
            heartNode = {
                play: () => {
                    const osc = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    osc.frequency.setValueAtTime(60, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.1);
                    g.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    osc.connect(g).connect(masterGainNode);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.15);
                }
            };

            // === DYNAMIC MUSIC: Static Noise Generator ===
            createStaticNoise();
        }

        // Create static/interference noise for dynamic music
        function createStaticNoise() {
            if (!audioCtx) return;

            const bufferSize = audioCtx.sampleRate * 2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            staticNoiseNode = audioCtx.createBufferSource();
            staticNoiseNode.buffer = buffer;
            staticNoiseNode.loop = true;

            staticNoiseGain = audioCtx.createGain();
            staticNoiseGain.gain.value = 0; // Start silent

            // Bandpass filter for radio static effect
            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = 1500;
            noiseFilter.Q.value = 0.5;

            staticNoiseNode.connect(noiseFilter).connect(staticNoiseGain).connect(masterGainNode);
            staticNoiseNode.start();
        }

        // Update dynamic music based on enemy proximity
        function updateDynamicMusic() {
            if (!audioCtx || !staticNoiseGain) return;

            // Find closest active enemy
            let closestDist = MAX_DEPTH;
            enemies.forEach(e => {
                if (!e.active || e.hp <= 0) return;
                let dx = e.x - player.x;
                let dy = e.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < closestDist) closestDist = dist;
            });

            // Calculate intensity: 10 units = safe (0), 2 units = max danger (1)
            musicIntensity = Math.max(0, Math.min(1, 1 - (closestDist - 2) / 8));

            // Update ambiance frequency (higher = more tense)
            if (ambianceNode) {
                ambianceNode.frequency.setTargetAtTime(
                    50 + musicIntensity * 80, // 50Hz â†’ 130Hz
                    audioCtx.currentTime, 0.3
                );
            }

            // Update static noise volume
            staticNoiseGain.gain.setTargetAtTime(
                musicIntensity * 0.12, // 0 â†’ 0.12
                audioCtx.currentTime, 0.2
            );
        }

        // === BLACKOUT SYSTEM ===
        function updateBlackout(dt) {
            if (isBlackout) {
                blackoutTimer += dt;
                if (blackoutTimer >= blackoutDuration) {
                    isBlackout = false;
                    blackoutTimer = 0;
                    nextBlackoutIn = 60 + Math.random() * 60; // Reset timer
                }
            } else {
                nextBlackoutIn -= dt;
                if (nextBlackoutIn <= 0) {
                    isBlackout = true;
                    blackoutDuration = 1.5 + Math.random() * 2; // 1.5-3.5 seconds
                    blackoutTimer = 0;
                    playSound('power_out');
                }
            }
        }


        // --- ENGINE CORE ---
        function loop(timestamp) {
            if (!running) return;

            // Fix: Cap dt to prevent massive first-frame delta causing enemies to fly off map
            let dt = (timestamp - lastTime) / 1000;
            if (dt > 0.1) dt = 0.1; // Max 100ms per frame to prevent physics explosion
            lastTime = timestamp;

            // PAUSE CHECK - Skip update but still render pause screen
            if (isPaused) {
                renderPauseScreen();
                requestAnimationFrame(loop);
                return;
            }

            update(dt);

            // Check if game ended during update
            if (!running) return;

            render();

            requestAnimationFrame(loop);
        }

        // --- PAUSE SCREEN ---
        function renderPauseScreen() {
            // Dim the existing render
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Pause text
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 28px Courier';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ffff';
            ctx.fillText('â¸ DURDURULDU', WIDTH / 2, 50);

            // Controls section
            ctx.shadowBlur = 0;
            ctx.font = '11px Courier';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#888';

            const controls = [
                'ðŸ–±ï¸ MOUSE = Etrafa Bak',
                'ðŸ–±ï¸ SOL TIK = BÃ¼yÃ¼ At',
                'ðŸ–±ï¸ SAÄž TIK = YakÄ±n SaldÄ±rÄ±',
                'âŒ¨ï¸ WASD = YÃ¼rÃ¼',
                'âŒ¨ï¸ SHIFT = KoÅŸ',
                'âŒ¨ï¸ E = KapÄ± AÃ§',
                'âŒ¨ï¸ SPACE = Durdur/Devam'
            ];

            let startY = 90;
            let centerX = WIDTH / 2 - 80;
            controls.forEach((ctrl, i) => {
                ctx.fillText(ctrl, centerX, startY + i * 16);
            });

            // Stats
            ctx.textAlign = 'center';
            ctx.font = '12px Courier';
            ctx.fillStyle = '#0f0';
            ctx.fillText('[ SPACE ile devam et ]', WIDTH / 2, HEIGHT - 50);

            ctx.font = '10px Courier';
            ctx.fillStyle = '#555';
            ctx.fillText(
                `SaÄŸlÄ±k: ${Math.floor(sanity)}% | Anahtar: ${collectedKeys}/3 | Stamina: ${Math.floor(stamina)}%`,
                WIDTH / 2, HEIGHT - 30
            );

            // Difficulty indicator
            const diffNames = { easy: 'KOLAY', normal: 'ORTA', hard: 'ZOR' };
            ctx.fillText(`Zorluk: ${diffNames[difficulty]}`, WIDTH / 2, HEIGHT - 15);
        }

        function update(dt) {
            if (gameWon) return;

            // === DYNAMIC MUSIC UPDATE ===
            updateDynamicMusic();

            // === BLACKOUT SYSTEM UPDATE ===
            updateBlackout(dt);

            // === STAMINA SYSTEM ===
            let isMoving = inputKeys.w || inputKeys.s || inputKeys.left || inputKeys.right;
            let wantToSprint = inputKeys.shift && isMoving;
            let canSprint = !isExhausted && stamina > 0;

            // Apply difficulty multiplier to stamina drain
            let staminaDrainWithDiff = staminaDrainRate * difficultySettings[difficulty].staminaDrainMult;

            if (wantToSprint && canSprint) {
                stamina -= staminaDrainWithDiff * dt;
                if (stamina <= 0) {
                    stamina = 0;
                    isExhausted = true;
                    playSound('exhausted');
                }
            } else {
                // Regenerate stamina when not sprinting
                if (stamina < maxStamina) {
                    stamina += staminaRegenRate * dt;
                    if (stamina > maxStamina) stamina = maxStamina;
                }
                // Recover from exhaustion
                if (isExhausted && stamina >= exhaustedThreshold) {
                    isExhausted = false;
                }
            }

            // Update stamina UI
            uiStamina.innerText = Math.floor(stamina) + "%";
            if (isExhausted) {
                uiStamina.style.color = '#ff4444';
            } else if (stamina < 30) {
                uiStamina.style.color = '#ffaa00';
            } else {
                uiStamina.style.color = '#00ff00';
            }

            // === STICKY GROUND CHECK ===
            let px = Math.floor(player.x);
            let py = Math.floor(player.y);
            let onStickyGround = (map[py] && map[py][px] === 5);
            let stickyMultiplier = onStickyGround ? 0.5 : 1.0;

            // === SPIDER WEB UPDATE ===
            spiderWebs = spiderWebs.filter(web => {
                web.lifetime -= dt;
                return web.lifetime > 0;
            });

            // Check if player is on a spider web
            let onWeb = spiderWebs.some(web => {
                let dx = player.x - web.x;
                let dy = player.y - web.y;
                return Math.sqrt(dx * dx + dy * dy) < web.radius;
            });
            let webMultiplier = onWeb ? 0.35 : 1.0; // 65% slow on web

            // Player Movement (WASD + Strafe)
            // Determine actual speed: base, sprint, sticky, web
            let baseSpeed = player.speed; // 2.5
            let sprintSpeed = 3.5;
            let actualSprint = (wantToSprint && canSprint);
            let currentSpeed = actualSprint ? sprintSpeed : baseSpeed;
            currentSpeed *= stickyMultiplier * webMultiplier;

            const moveStep = currentSpeed * dt;

            let moveX = 0;
            let moveY = 0;

            // Forward/Back
            if (inputKeys.w) {
                moveX += Math.cos(player.dir) * moveStep;
                moveY += Math.sin(player.dir) * moveStep;
            }
            if (inputKeys.s) {
                moveX -= Math.cos(player.dir) * moveStep;
                moveY -= Math.sin(player.dir) * moveStep;
            }

            // Strafe Left/Right
            if (inputKeys.left) { // A
                moveX += Math.cos(player.dir - Math.PI / 2) * moveStep;
                moveY += Math.sin(player.dir - Math.PI / 2) * moveStep;
            }
            if (inputKeys.right) { // D
                moveX += Math.cos(player.dir + Math.PI / 2) * moveStep;
                moveY += Math.sin(player.dir + Math.PI / 2) * moveStep;
            }

            const newX = player.x + moveX;
            const newY = player.y + moveY;

            // Collision (allow walking on keys, exit door, and sticky ground)
            if (map[Math.floor(newY)] && (map[Math.floor(newY)][Math.floor(player.x)] === 0 || map[Math.floor(newY)][Math.floor(player.x)] >= 2)) player.y = newY;
            if (map[Math.floor(player.y)] && (map[Math.floor(player.y)][Math.floor(newX)] === 0 || map[Math.floor(player.y)][Math.floor(newX)] >= 2)) player.x = newX;

            // Item Pickup
            px = Math.floor(player.x);
            py = Math.floor(player.y);
            if (map[py] && map[py][px] === 2) {
                map[py][px] = 0;
                collectedKeys++;
                uiKeys.innerText = `${collectedKeys}/3`;
                if (collectedKeys < 3) {
                    uiMsg.innerText = `ðŸ”‘ KEY ${collectedKeys}/3 ACQUIRED!`;
                } else {
                    uiMsg.innerText = "ðŸšª ALL KEYS! FIND THE EXIT DOOR!";
                    exitDoor.active = true;
                }
                setTimeout(() => uiMsg.innerText = "", 3000);
                playSound('pickup');
            }

            // Exit Door Interaction - E key escape
            let distToExit = Math.sqrt(
                Math.pow(player.x - exitDoor.x, 2) +
                Math.pow(player.y - exitDoor.y, 2)
            );

            // Check if near exit door
            if (distToExit < 3) {
                if (exitDoor.active) {
                    uiMsg.innerText = "ðŸšª [E] KAPIYI AÃ‡ VE KAÃ‡!";
                    if (inputKeys.e) {
                        victory();
                        return;
                    }
                } else {
                    uiMsg.innerText = "ï¿½ KapÄ± kilitli! 3 anahtar bul.";
                }
            }

            // MULTI-ENEMY AI SYSTEM
            if (freezeTimer > 0) {
                freezeTimer -= dt;
            }

            enemies.forEach((enemy, idx) => {
                if (!enemy.active) return;

                let dx = player.x - enemy.x;
                let dy = player.y - enemy.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                enemy.phase += dt * 5;

                // Movement based on enemy type - Apply difficulty multiplier
                let moveX = 0, moveY = 0;
                let speedMult = difficultySettings[difficulty].enemySpeedMult;

                if (enemy.type === 'stalker') {
                    // Shadow Stalker - Slowly follows player
                    moveX = (dx / dist) * enemy.speed * speedMult * dt * 0.4;
                    moveY = (dy / dist) * enemy.speed * speedMult * dt * 0.4;
                }
                else if (enemy.type === 'spider') {
                    // Spider - Erratic spider-like movement with web shooting
                    enemy.legPhase += dt * 8;
                    let erratic = Math.sin(enemy.phase * 3) * 0.5;
                    moveX = (dx / dist + erratic) * enemy.speed * speedMult * dt * 0.5;
                    moveY = (dy / dist + Math.cos(enemy.phase * 4) * 0.5) * enemy.speed * speedMult * dt * 0.5;

                    // Spider web shooting
                    if (!enemy.webCooldown) enemy.webCooldown = 0;
                    enemy.webCooldown -= dt;
                    if (dist < 6 && enemy.webCooldown <= 0) {
                        spiderWebs.push({ x: player.x, y: player.y, radius: 1.2, lifetime: 4 });
                        enemy.webCooldown = 5;
                        playSound('web_shot');
                    }
                }
                else if (enemy.type === 'glitch') {
                    // Glitch Entity - Teleports randomly
                    enemy.teleportTimer += dt;
                    if (enemy.teleportTimer > 3 + Math.random() * 2) {
                        // Teleport to random valid position near player
                        let angle = Math.random() * Math.PI * 2;
                        let teleportDist = 3 + Math.random() * 4;
                        let newX = player.x + Math.cos(angle) * teleportDist;
                        let newY = player.y + Math.sin(angle) * teleportDist;
                        newX = Math.max(1, Math.min(MAP_SIZE - 2, newX));
                        newY = Math.max(1, Math.min(MAP_SIZE - 2, newY));
                        if (map[Math.floor(newY)][Math.floor(newX)] !== 1) {
                            enemy.x = newX;
                            enemy.y = newY;
                            glitchEffect = 1.0;
                            playSound('glitch');
                        }
                        enemy.teleportTimer = 0;
                    }
                    moveX = (dx / dist) * enemy.speed * speedMult * dt * 0.3;
                    moveY = (dy / dist) * enemy.speed * speedMult * dt * 0.3;
                }
                else if (enemy.type === 'watcher') {
                    // The Watcher - Freezes player when in view
                    let spriteAngle = Math.atan2(dy, dx) - player.dir;
                    while (spriteAngle < -Math.PI) spriteAngle += 2 * Math.PI;
                    while (spriteAngle > Math.PI) spriteAngle -= 2 * Math.PI;

                    if (Math.abs(spriteAngle) < FOV / 2 && dist < MAX_DEPTH) {
                        // Player is looking at the Watcher
                        enemy.stareTimer += dt;
                        if (enemy.stareTimer > 0.5) {
                            freezeTimer = 0.3;
                            sanity -= dt * 8;
                        }
                    } else {
                        enemy.stareTimer = 0;
                        moveX = (dx / dist) * enemy.speed * speedMult * dt * 0.6;
                        moveY = (dy / dist) * enemy.speed * speedMult * dt * 0.6;
                    }
                }

                // Apply movement with collision
                let ex = enemy.x + moveX;
                let ey = enemy.y + moveY;
                if (map[Math.floor(ey)][Math.floor(ex)] !== 1) {
                    if (freezeTimer <= 0 || enemy.type === 'watcher') {
                        enemy.x = ex;
                        enemy.y = ey;
                    }
                }

                // Proximity effects
                if (dist < 4) {
                    // Heartbeat based on closest enemy
                    let beatRate = Math.max(150, dist * 80);
                    if (Date.now() % Math.floor(beatRate) < 20) heartNode.play();

                    // Screen shake when very close
                    if (dist < 2) {
                        screenShake = Math.max(screenShake, (2 - dist) * 3);
                    }
                }

                // Sanity drain based on proximity
                if (dist < 3) sanity -= dt * (4 - dist) * 2;

                // Death check
                if (dist < 0.5) {
                    gameOver(enemy.type);
                }
            });

            // Decay effects
            screenShake *= 0.9;
            glitchEffect *= 0.95;
            staffGlow *= 0.9;
            staffCooldown -= dt;

            // UPDATE SPELL PROJECTILES
            spellProjectiles = spellProjectiles.filter(spell => {
                // Move spell
                spell.x += Math.cos(spell.dir) * spell.speed * dt;
                spell.y += Math.sin(spell.dir) * spell.speed * dt;
                spell.life -= dt;

                // Check wall collision
                if (spell.x < 0 || spell.x >= MAP_SIZE || spell.y < 0 || spell.y >= MAP_SIZE) {
                    return false;
                }
                if (map[Math.floor(spell.y)][Math.floor(spell.x)] === 1) {
                    // Wall collision
                    if (spell.staffType === 'electric') {
                        // Electric wall hit effect (spawn sparks)
                        // Simple logic: we don't spawn new physics objects, but we could play a sound
                        // or add a temporary visual effect if we had a particle system.
                        // For now, let's just make the screen flash yellow to simulate "grounding"
                        if (dist < 5) screenShake = 2;
                    }
                    return false;
                }

                // Check enemy collision
                for (let enemy of enemies) {
                    if (!enemy.active || enemy.hp <= 0) continue;

                    let dx = spell.x - enemy.x;
                    let dy = spell.y - enemy.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 0.8) {
                        // HIT! Damage enemy
                        enemy.hp -= spell.damage;
                        enemy.hitFlash = 1.0;
                        screenShake = 3;

                        // ENEMY SCREAM!
                        playSound('enemy_scream', enemy.type);

                        // Show damage message
                        uiMsg.innerText = `VURUÅž! -${spell.damage} HP`;
                        setTimeout(() => uiMsg.innerText = "", 1500);

                        // Check if enemy died
                        if (enemy.hp <= 0) {
                            enemy.active = false;
                            playSound('enemy_death', enemy.type);
                            uiMsg.innerText = "MÃœHFAK Ä°BNELERÄ° Ä°NDÄ°RÄ°LDÄ°!";
                            setTimeout(() => uiMsg.innerText = "", 2000);
                        }

                        return false; // Remove spell
                    }
                }

                return spell.life > 0;
            });

            // Decay enemy hit flash
            enemies.forEach(enemy => {
                if (enemy.hitFlash > 0) {
                    enemy.hitFlash *= 0.85;
                }
            });

            // === SAW TRAP UPDATE ===
            sawTraps.forEach(saw => {
                saw.phase += dt * saw.speed;

                // Calculate position along path using sine wave (ping-pong)
                let t = (Math.sin(saw.phase) + 1) / 2; // 0 to 1
                saw.x = saw.startX + (saw.endX - saw.startX) * t;
                saw.y = saw.startY + (saw.endY - saw.startY) * t;

                // Check collision with player
                let dx = player.x - saw.x;
                let dy = player.y - saw.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 0.8) {
                    // Player hit by saw!
                    sanity -= saw.damage * dt;
                    screenShake = 5;

                    // Play saw sound periodically
                    if (Math.random() < 0.1) {
                        playSound('saw_hit');
                    }
                }
            });

            if (sanity < 0) gameOver('insanity');
            uiSanity.innerText = Math.floor(sanity) + "%";
        }

        function render() {
            // Check if player is on sticky ground for floor color
            let floorPx = Math.floor(player.x);
            let floorPy = Math.floor(player.y);
            let onSticky = (map[floorPy] && map[floorPy][floorPx] === 5);

            // Ceiling/Floor
            ctx.fillStyle = "#111";
            ctx.fillRect(0, 0, WIDTH, HEIGHT / 2);
            // Floor color changes when on sticky ground
            ctx.fillStyle = onSticky ? "#3a1a10" : "#222";
            ctx.fillRect(0, HEIGHT / 2, WIDTH, HEIGHT / 2);

            // Show warning message when on sticky ground
            if (onSticky) {
                ctx.fillStyle = 'rgba(100, 40, 20, 0.3)';
                ctx.fillRect(0, HEIGHT / 2, WIDTH, HEIGHT / 2);
            }

            // Raycasting
            for (let x = 0; x < RAYS; x++) {
                const rayAngle = (player.dir - FOV / 2.0) + (x / RAYS) * FOV;
                const eyeX = Math.cos(rayAngle);
                const eyeY = Math.sin(rayAngle);

                let distToWall = 0;
                let hitWall = false;
                let texture = 0; // 0: Wall, 1: Key

                let testX = player.x;
                let testY = player.y;

                // DDA Algorithm (Simplified)
                while (!hitWall && distToWall < MAX_DEPTH) {
                    distToWall += 0.1;
                    testX = player.x + eyeX * distToWall;
                    testY = player.y + eyeY * distToWall;

                    if (testX < 0 || testX >= MAP_SIZE || testY < 0 || testY >= MAP_SIZE) {
                        hitWall = true;
                        distToWall = MAX_DEPTH;
                    } else {
                        let block = map[Math.floor(testY)][Math.floor(testX)];
                        if (block === 1) { hitWall = true; texture = 1; }
                        else if (block === 2) {
                            // Render Key as separate sprite? No, simplified: Color change
                        }
                    }
                }

                // Fisheye fix
                let ca = player.dir - rayAngle;
                if (ca < 0) ca += 2 * Math.PI;
                if (ca > 2 * Math.PI) ca -= 2 * Math.PI;
                distToWall = distToWall * Math.cos(ca);

                // Wall Height
                const ceiling = HEIGHT / 2.0 - HEIGHT / distToWall;
                const floor = HEIGHT - ceiling;
                const wallHeight = floor - ceiling;

                // Draw Wall strip
                let color = Math.floor(255 / (distToWall * 0.8)); // Distance shading
                if (color > 255) color = 255;

                ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;

                // Key is special logic, simplistic rendering for snippet
                /* Advanced: Sprite rendering is complex for 1 file. 
                   We will indicate items via UI/HUD radar or proximity sound. */

                const w = WIDTH / RAYS;
                ctx.fillRect(x * w, ceiling, w, wallHeight);
            }

            // Apply screen shake
            if (screenShake > 0.1) {
                ctx.save();
                ctx.translate(
                    (Math.random() - 0.5) * screenShake * 5,
                    (Math.random() - 0.5) * screenShake * 5
                );
            }

            // Apply glitch effect overlay
            if (glitchEffect > 0.1) {
                ctx.fillStyle = `rgba(255, 0, 255, ${glitchEffect * 0.3})`;
                for (let i = 0; i < 10; i++) {
                    let y = Math.random() * HEIGHT;
                    let h = Math.random() * 20;
                    ctx.fillRect(0, y, WIDTH, h);
                }
            }

            // RENDER ALL SCARY ENEMIES
            enemies.forEach((enemy) => {
                if (!enemy.active) return;

                let dx = enemy.x - player.x;
                let dy = enemy.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                let spriteAngle = Math.atan2(dy, dx) - player.dir;
                while (spriteAngle < -Math.PI) spriteAngle += 2 * Math.PI;
                while (spriteAngle > Math.PI) spriteAngle -= 2 * Math.PI;

                // Is visible in FOV?
                if (Math.abs(spriteAngle) < FOV / 1.5 && dist < MAX_DEPTH && dist > 0.5) {

                    // WALL OCCLUSION CHECK - Cast ray to enemy to see if wall blocks view
                    let rayDir = Math.atan2(dy, dx);
                    let blocked = false;
                    let checkDist = 0.5;
                    while (checkDist < dist - 0.3) {
                        let checkX = player.x + Math.cos(rayDir) * checkDist;
                        let checkY = player.y + Math.sin(rayDir) * checkDist;
                        if (map[Math.floor(checkY)] && map[Math.floor(checkY)][Math.floor(checkX)] === 1) {
                            blocked = true;
                            break;
                        }
                        checkDist += 0.3;
                    }

                    if (blocked) return; // Don't render if wall blocks view
                    let screenX = (0.5 * (spriteAngle / (FOV / 2)) + 0.5) * WIDTH;
                    let spriteHeight = HEIGHT / dist;
                    let spriteWidth = spriteHeight * 0.6;
                    let pulse = Math.sin(enemy.phase) * 0.1 + 1;

                    if (enemy.type === 'stalker') {
                        // SHADOW STALKER - Dark figure with glowing red eyes and tendrils
                        // Body - Tall dark silhouette
                        ctx.fillStyle = `rgba(10, 0, 15, ${1 - dist / 12})`;
                        ctx.fillRect(screenX - spriteWidth / 2, HEIGHT / 2 - spriteHeight / 2, spriteWidth, spriteHeight * 1.2);

                        // Tendrils coming from body
                        ctx.strokeStyle = `rgba(30, 0, 40, ${1 - dist / 10})`;
                        ctx.lineWidth = 3;
                        for (let t = 0; t < 6; t++) {
                            ctx.beginPath();
                            let tx = screenX + (t - 3) * spriteWidth / 6;
                            let baseY = HEIGHT / 2 + spriteHeight / 3;
                            ctx.moveTo(tx, baseY);
                            let wave = Math.sin(enemy.phase + t) * 20;
                            ctx.quadraticCurveTo(tx + wave, baseY + spriteHeight / 2, tx + wave * 2, baseY + spriteHeight);
                            ctx.stroke();
                        }

                        // Glowing RED eyes
                        let eyeGlow = 20 + Math.sin(enemy.phase * 2) * 10;
                        ctx.shadowBlur = eyeGlow;
                        ctx.shadowColor = 'red';
                        ctx.fillStyle = `rgba(255, 0, 0, ${1 - dist / 8})`;
                        ctx.beginPath();
                        ctx.arc(screenX - spriteWidth / 5, HEIGHT / 2 - spriteHeight / 4, spriteWidth / 8 * pulse, 0, Math.PI * 2);
                        ctx.arc(screenX + spriteWidth / 5, HEIGHT / 2 - spriteHeight / 4, spriteWidth / 8 * pulse, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;

                        // Gaping mouth
                        ctx.fillStyle = `rgba(50, 0, 0, ${1 - dist / 10})`;
                        ctx.beginPath();
                        ctx.ellipse(screenX, HEIGHT / 2, spriteWidth / 4, spriteHeight / 8 * pulse, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    else if (enemy.type === 'spider') {
                        // SPIDER - 8-legged horror with glowing red eyes
                        let crawlOffset = Math.sin(enemy.phase * 4) * 5;
                        let legPhaseAnim = enemy.legPhase || 0;

                        // Main body (oval abdomen)
                        ctx.fillStyle = `rgba(20, 10, 15, ${1 - dist / 10})`;
                        ctx.beginPath();
                        ctx.ellipse(screenX, HEIGHT / 2 + crawlOffset, spriteWidth / 2.5, spriteHeight / 3, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Head (smaller oval)
                        ctx.beginPath();
                        ctx.ellipse(screenX, HEIGHT / 2 - spriteHeight / 4 + crawlOffset, spriteWidth / 4, spriteHeight / 5, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // 8 Spider legs with joints
                        ctx.strokeStyle = `rgba(40, 20, 30, ${1 - dist / 8})`;
                        ctx.lineWidth = 3;
                        for (let leg = 0; leg < 8; leg++) {
                            ctx.beginPath();
                            let side = leg < 4 ? -1 : 1;
                            let legIndex = leg % 4;
                            let baseX = screenX + side * spriteWidth / 6;
                            let legAnim = Math.sin(legPhaseAnim + leg * 0.8) * 10;

                            // First segment
                            let midX = baseX + side * spriteWidth / 3;
                            let midY = HEIGHT / 2 + crawlOffset - spriteHeight / 6 + legIndex * 8;
                            ctx.moveTo(baseX, HEIGHT / 2 + crawlOffset);
                            ctx.lineTo(midX, midY + legAnim);

                            // Second segment (to ground)
                            let endX = midX + side * spriteWidth / 4;
                            let endY = HEIGHT / 2 + spriteHeight / 2 + Math.abs(legAnim) * 0.5;
                            ctx.lineTo(endX, endY);
                            ctx.stroke();
                        }

                        // Multiple glowing red eyes (8 eyes)
                        ctx.shadowBlur = 12;
                        ctx.shadowColor = '#ff0000';
                        ctx.fillStyle = `rgba(255, 0, 0, ${1 - dist / 8})`;
                        for (let eye = 0; eye < 8; eye++) {
                            ctx.beginPath();
                            let eyeX = screenX + (eye % 4 - 1.5) * spriteWidth / 12;
                            let eyeY = HEIGHT / 2 - spriteHeight / 4 + crawlOffset + Math.floor(eye / 4) * 6 - 8;
                            let eyeSize = eye < 2 || eye > 5 ? spriteWidth / 20 : spriteWidth / 14;
                            ctx.arc(eyeX, eyeY, eyeSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.shadowBlur = 0;

                        // Fangs
                        ctx.strokeStyle = `rgba(150, 100, 80, ${1 - dist / 8})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(screenX - spriteWidth / 12, HEIGHT / 2 - spriteHeight / 8 + crawlOffset);
                        ctx.lineTo(screenX - spriteWidth / 10, HEIGHT / 2 + spriteHeight / 12 + crawlOffset);
                        ctx.moveTo(screenX + spriteWidth / 12, HEIGHT / 2 - spriteHeight / 8 + crawlOffset);
                        ctx.lineTo(screenX + spriteWidth / 10, HEIGHT / 2 + spriteHeight / 12 + crawlOffset);
                        ctx.stroke();
                    }
                    else if (enemy.type === 'glitch') {
                        // GLITCH ENTITY - Distorted static humanoid
                        // Glitchy body made of static lines
                        for (let i = 0; i < 20; i++) {
                            let glitchY = HEIGHT / 2 - spriteHeight / 2 + (i / 20) * spriteHeight;
                            let glitchOffset = (Math.random() - 0.5) * 30 * (1 - dist / MAX_DEPTH);
                            let glitchWidth = spriteWidth * (0.5 + Math.random() * 0.5);

                            // RGB split effect
                            ctx.fillStyle = `rgba(255, 0, 0, ${0.5 - dist / 20})`;
                            ctx.fillRect(screenX - glitchWidth / 2 + glitchOffset - 3, glitchY, glitchWidth, spriteHeight / 20);
                            ctx.fillStyle = `rgba(0, 255, 0, ${0.5 - dist / 20})`;
                            ctx.fillRect(screenX - glitchWidth / 2 + glitchOffset, glitchY, glitchWidth, spriteHeight / 20);
                            ctx.fillStyle = `rgba(0, 0, 255, ${0.5 - dist / 20})`;
                            ctx.fillRect(screenX - glitchWidth / 2 + glitchOffset + 3, glitchY, glitchWidth, spriteHeight / 20);
                        }

                        // Static face
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.8 - dist / 10})`;
                        ctx.fillRect(screenX - spriteWidth / 4, HEIGHT / 2 - spriteHeight / 3, spriteWidth / 8, spriteHeight / 20);
                        ctx.fillRect(screenX + spriteWidth / 8, HEIGHT / 2 - spriteHeight / 3, spriteWidth / 8, spriteHeight / 20);

                        // Glitching mouth that opens
                        let mouthOpen = Math.abs(Math.sin(enemy.phase * 8)) * spriteHeight / 10;
                        ctx.fillStyle = `rgba(0, 0, 0, ${1 - dist / 8})`;
                        ctx.fillRect(screenX - spriteWidth / 6, HEIGHT / 2 - spriteHeight / 6, spriteWidth / 3, mouthOpen);
                    }
                    else if (enemy.type === 'watcher') {
                        // THE WATCHER - Giant floating bloodshot eye
                        let eyeSize = spriteWidth * 0.8 * pulse;

                        // Outer eye (white with bloodshot veins)
                        ctx.fillStyle = `rgba(240, 230, 220, ${1 - dist / 12})`;
                        ctx.beginPath();
                        ctx.ellipse(screenX, HEIGHT / 2, eyeSize, eyeSize * 0.7, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Bloodshot veins
                        ctx.strokeStyle = `rgba(200, 50, 50, ${0.7 - dist / 15})`;
                        ctx.lineWidth = 2;
                        for (let v = 0; v < 12; v++) {
                            ctx.beginPath();
                            let angle = (v / 12) * Math.PI * 2 + enemy.phase * 0.1;
                            ctx.moveTo(screenX + Math.cos(angle) * eyeSize * 0.3, HEIGHT / 2 + Math.sin(angle) * eyeSize * 0.2);
                            let wobble = Math.sin(enemy.phase + v) * 5;
                            ctx.quadraticCurveTo(
                                screenX + Math.cos(angle) * eyeSize * 0.6 + wobble,
                                HEIGHT / 2 + Math.sin(angle) * eyeSize * 0.4,
                                screenX + Math.cos(angle) * eyeSize * 0.95,
                                HEIGHT / 2 + Math.sin(angle) * eyeSize * 0.65
                            );
                            ctx.stroke();
                        }

                        // Iris (follows player - always looking at you)
                        ctx.fillStyle = `rgba(50, 100, 80, ${1 - dist / 10})`;
                        ctx.beginPath();
                        ctx.arc(screenX, HEIGHT / 2, eyeSize * 0.4, 0, Math.PI * 2);
                        ctx.fill();

                        // Pupil (shrinks when looking at player)
                        let pupilSize = enemy.stareTimer > 0.5 ? eyeSize * 0.1 : eyeSize * 0.25;
                        ctx.fillStyle = `rgba(0, 0, 0, ${1 - dist / 10})`;
                        ctx.beginPath();
                        ctx.arc(screenX, HEIGHT / 2, pupilSize, 0, Math.PI * 2);
                        ctx.fill();

                        // Eerie glow when staring
                        if (enemy.stareTimer > 0.5) {
                            ctx.shadowBlur = 30;
                            ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
                            ctx.strokeStyle = `rgba(255, 100, 100, ${0.5 + Math.sin(enemy.phase * 5) * 0.3})`;
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.ellipse(screenX, HEIGHT / 2, eyeSize * 1.1, eyeSize * 0.8, 0, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                        }
                    }

                    // ===== HEALTH BAR above enemy =====
                    if (enemy.hp > 0 && enemy.hp < enemy.maxHp) {
                        let barWidth = spriteWidth * 0.8;
                        let barHeight = 6;
                        let barX = screenX - barWidth / 2;
                        let barY = HEIGHT / 2 - spriteHeight / 2 - 15;

                        // Background
                        ctx.fillStyle = 'rgba(50, 0, 0, 0.8)';
                        ctx.fillRect(barX, barY, barWidth, barHeight);

                        // Health fill
                        let hpPercent = enemy.hp / enemy.maxHp;
                        let hpColor = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
                        ctx.fillStyle = hpColor;
                        ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);

                        // Border
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(barX, barY, barWidth, barHeight);
                    }

                    // ===== HIT FLASH overlay =====
                    if (enemy.hitFlash > 0.1) {
                        ctx.fillStyle = `rgba(255, 100, 255, ${enemy.hitFlash * 0.5})`;
                        ctx.fillRect(screenX - spriteWidth / 2 - 5, HEIGHT / 2 - spriteHeight / 2, spriteWidth + 10, spriteHeight);
                    }
                }
            });

            // ===== RENDER SPELL PROJECTILES =====
            spellProjectiles.forEach(spell => {
                let dx = spell.x - player.x;
                let dy = spell.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                let spellAngle = Math.atan2(dy, dx) - player.dir;

                while (spellAngle < -Math.PI) spellAngle += 2 * Math.PI;
                while (spellAngle > Math.PI) spellAngle -= 2 * Math.PI;

                if (Math.abs(spellAngle) < FOV / 1.5 && dist < MAX_DEPTH && dist > 0.3) {
                    let screenX = (0.5 * (spellAngle / (FOV / 2)) + 0.5) * WIDTH;
                    let spellSize = 30 / dist;
                    let time = Date.now() / 1000;

                    // Asa tipine gÃ¶re farklÄ± bÃ¼yÃ¼ Ã§izimi
                    switch (spell.staffType) {
                        case 'electric':
                            // SarÄ± elektrik ÅŸimÅŸeÄŸi
                            ctx.shadowBlur = 30;
                            ctx.shadowColor = '#ffff00';
                            ctx.strokeStyle = '#ffff00';
                            ctx.lineWidth = 3;
                            // Zikzak ÅŸimÅŸek Ã§iz
                            ctx.beginPath();
                            ctx.moveTo(screenX - spellSize, HEIGHT / 2);
                            for (let i = 0; i < 5; i++) {
                                let zigX = screenX - spellSize + (i + 1) * (spellSize * 2 / 5);
                                let zigY = HEIGHT / 2 + (i % 2 === 0 ? -1 : 1) * (spellSize * 0.6);
                                ctx.lineTo(zigX, zigY);
                            }
                            ctx.stroke();
                            // Merkez parlaklÄ±k
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.arc(screenX, HEIGHT / 2, spellSize * 0.4, 0, Math.PI * 2);
                            ctx.fill();
                            // Sparklar
                            for (let i = 0; i < 4; i++) {
                                let sAngle = time * 10 + i * Math.PI / 2;
                                ctx.fillStyle = '#ffff00';
                                ctx.beginPath();
                                ctx.arc(
                                    screenX + Math.cos(sAngle) * spellSize * 0.8,
                                    HEIGHT / 2 + Math.sin(sAngle) * spellSize * 0.8,
                                    2, 0, Math.PI * 2
                                );
                                ctx.fill();
                            }
                            break;

                        case 'paper':
                            // Beyaz dÃ¶nen kaÄŸÄ±t
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#ffffff';
                            ctx.fillStyle = '#f5f5f5';
                            ctx.save();
                            ctx.translate(screenX, HEIGHT / 2);
                            ctx.rotate(time * 5);
                            // KaÄŸÄ±t parÃ§alarÄ±
                            for (let i = 0; i < 3; i++) {
                                ctx.fillStyle = `rgba(255, 255, 255, ${0.9 - i * 0.2})`;
                                ctx.fillRect(-spellSize * 0.8, -spellSize * 0.2 + i * 4, spellSize * 1.6, spellSize * 0.3);
                            }
                            ctx.restore();
                            break;

                        case 'electronic':
                            {
                                // YeÅŸil dijital/pixel - MATRIX TRAIL EFFECT
                                ctx.shadowBlur = 20;
                                ctx.shadowColor = '#00ff00';
                                let pixelSize = Math.max(2, spellSize / 4);

                                // Matrix Trail (Binary Rain) behind the projectile
                                for (let k = 1; k < 5; k++) {
                                    let trailX = screenX - Math.cos(spellAngle) * k * 20;
                                    let trailY = HEIGHT / 2 + (k * 5) - 20; // Fake 3D perspective
                                    ctx.font = `${Math.max(8, spellSize / 2)}px monospace`;
                                    ctx.fillStyle = `rgba(0, 255, 0, ${0.6 / k})`;
                                    ctx.fillText(Math.random() > 0.5 ? '1' : '0', trailX, trailY);
                                }

                                // Main projectile (pixel cluster)
                                for (let px = -2; px <= 2; px++) {
                                    for (let py = -2; py <= 2; py++) {
                                        if (Math.abs(px) + Math.abs(py) <= 2) {
                                            let alpha = 1 - (Math.abs(px) + Math.abs(py)) * 0.25;
                                            let flicker = Math.random() > 0.8 ? 0.5 : 1;
                                            ctx.fillStyle = `rgba(0, 255, 0, ${alpha * flicker})`;
                                            ctx.fillRect(
                                                screenX + px * pixelSize - pixelSize / 2,
                                                HEIGHT / 2 + py * pixelSize - pixelSize / 2,
                                                pixelSize, pixelSize
                                            );
                                        }
                                    }
                                }
                            }
                            break;

                        default:
                            // Klasik mor orb
                            ctx.shadowBlur = 25;
                            ctx.shadowColor = '#ff00ff';
                            ctx.beginPath();
                            let gradient = ctx.createRadialGradient(screenX, HEIGHT / 2, 0, screenX, HEIGHT / 2, spellSize);
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                            gradient.addColorStop(0.3, 'rgba(200, 100, 255, 0.9)');
                            gradient.addColorStop(1, 'rgba(100, 0, 200, 0)');
                            ctx.fillStyle = gradient;
                            ctx.arc(screenX, HEIGHT / 2, spellSize, 0, Math.PI * 2);
                            ctx.fill();
                    }
                    ctx.shadowBlur = 0;
                }
            });

            // ===== RENDER KEYS AS 3D FLOATING SPRITES =====
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (!map[y] || map[y][x] !== 2) continue;

                    let keyX = x + 0.5;
                    let keyY = y + 0.5;
                    let dx = keyX - player.x;
                    let dy = keyY - player.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    let keyAngle = Math.atan2(dy, dx) - player.dir;

                    while (keyAngle < -Math.PI) keyAngle += 2 * Math.PI;
                    while (keyAngle > Math.PI) keyAngle -= 2 * Math.PI;

                    if (Math.abs(keyAngle) < FOV / 1.5 && dist < MAX_DEPTH && dist > 0.5) {
                        // WALL OCCLUSION CHECK - Cast ray to key to see if wall blocks view
                        let rayDir = Math.atan2(dy, dx);
                        let blocked = false;
                        let checkDist = 0.5;
                        while (checkDist < dist - 0.3) {
                            let checkX = player.x + Math.cos(rayDir) * checkDist;
                            let checkY = player.y + Math.sin(rayDir) * checkDist;
                            if (map[Math.floor(checkY)] && map[Math.floor(checkY)][Math.floor(checkX)] === 1) {
                                blocked = true;
                                break;
                            }
                            checkDist += 0.3;
                        }

                        if (blocked) continue; // Don't render if wall blocks view

                        let screenX = (0.5 * (keyAngle / (FOV / 2)) + 0.5) * WIDTH;
                        let keySize = 40 / dist;
                        let bobY = Math.sin(Date.now() / 200) * 5;

                        // Golden key glow
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#FFD700';

                        // Key body
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(screenX, HEIGHT / 2 + bobY, keySize * 0.4, 0, Math.PI * 2);
                        ctx.fill();

                        // Key shaft
                        ctx.strokeStyle = '#DAA520';
                        ctx.lineWidth = keySize * 0.15;
                        ctx.beginPath();
                        ctx.moveTo(screenX, HEIGHT / 2 + bobY + keySize * 0.3);
                        ctx.lineTo(screenX, HEIGHT / 2 + bobY + keySize);
                        ctx.stroke();

                        // Key teeth
                        ctx.beginPath();
                        ctx.moveTo(screenX, HEIGHT / 2 + bobY + keySize * 0.7);
                        ctx.lineTo(screenX + keySize * 0.2, HEIGHT / 2 + bobY + keySize * 0.7);
                        ctx.moveTo(screenX, HEIGHT / 2 + bobY + keySize * 0.9);
                        ctx.lineTo(screenX + keySize * 0.15, HEIGHT / 2 + bobY + keySize * 0.9);
                        ctx.stroke();

                        ctx.shadowBlur = 0;
                    }
                }
            }

            // ===== RENDER EXIT DOOR AS 3D SPRITE =====
            if (exitDoor.x > 0) {
                let dx = exitDoor.x - player.x;
                let dy = exitDoor.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                let doorAngle = Math.atan2(dy, dx) - player.dir;

                while (doorAngle < -Math.PI) doorAngle += 2 * Math.PI;
                while (doorAngle > Math.PI) doorAngle -= 2 * Math.PI;

                if (Math.abs(doorAngle) < FOV / 1.5 && dist < MAX_DEPTH && dist > 0.5) {
                    // WALL OCCLUSION CHECK - Don't render if wall blocks view
                    let rayDir = Math.atan2(dy, dx);
                    let blocked = false;
                    let checkDist = 0.5;
                    while (checkDist < dist - 0.3) {
                        let checkX = player.x + Math.cos(rayDir) * checkDist;
                        let checkY = player.y + Math.sin(rayDir) * checkDist;
                        if (map[Math.floor(checkY)] && map[Math.floor(checkY)][Math.floor(checkX)] === 1) {
                            blocked = true;
                            break;
                        }
                        checkDist += 0.3;
                    }

                    if (!blocked) { // Only render if not blocked
                        let screenX = (0.5 * (doorAngle / (FOV / 2)) + 0.5) * WIDTH;
                        let doorHeight = HEIGHT / dist;
                        let doorWidth = doorHeight * 0.6;

                        // Blood around door
                        ctx.fillStyle = 'rgba(100, 0, 0, 0.6)';
                        for (let i = 0; i < 8; i++) {
                            let bx = screenX + (Math.random() - 0.5) * doorWidth * 2;
                            let by = HEIGHT / 2 + (Math.random() - 0.5) * doorHeight;
                            ctx.beginPath();
                            ctx.arc(bx, by, 5 + Math.random() * 10, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Door frame
                        if (exitDoor.active) {
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#00FF00';
                            ctx.fillStyle = '#004400';
                        } else {
                            ctx.fillStyle = '#331111';
                        }
                        ctx.fillRect(screenX - doorWidth / 2, HEIGHT / 2 - doorHeight / 2, doorWidth, doorHeight);

                        // Door details
                        ctx.strokeStyle = exitDoor.active ? '#00FF88' : '#660000';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(screenX - doorWidth / 2 + 5, HEIGHT / 2 - doorHeight / 2 + 5, doorWidth - 10, doorHeight - 10);

                        // Handle
                        ctx.fillStyle = exitDoor.active ? '#FFFF00' : '#444444';
                        ctx.beginPath();
                        ctx.arc(screenX + doorWidth / 4, HEIGHT / 2, doorWidth / 10, 0, Math.PI * 2);
                        ctx.fill();

                        // "EXIT" text if active
                        if (exitDoor.active && dist < 5) {
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = '#00FF00';
                            ctx.fillStyle = '#00FF00';
                            ctx.font = `${Math.floor(20 / dist)}px Courier`;
                            ctx.textAlign = 'center';
                            ctx.fillText('EXIT', screenX, HEIGHT / 2 - doorHeight / 2 - 10);
                            ctx.fillText('[E]', screenX, HEIGHT / 2);
                        }

                        ctx.shadowBlur = 0;
                    }
                }
            }

            // ===== RENDER SAW TRAPS AS 3D SPRITES =====
            sawTraps.forEach(saw => {
                let dx = saw.x - player.x;
                let dy = saw.y - player.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                let sawAngle = Math.atan2(dy, dx) - player.dir;

                while (sawAngle < -Math.PI) sawAngle += 2 * Math.PI;
                while (sawAngle > Math.PI) sawAngle -= 2 * Math.PI;

                if (Math.abs(sawAngle) < FOV / 1.5 && dist < MAX_DEPTH && dist > 0.3) {
                    // WALL OCCLUSION CHECK - Don't render if wall blocks view
                    let rayDir = Math.atan2(dy, dx);
                    let blocked = false;
                    let checkDist = 0.5;
                    while (checkDist < dist - 0.3) {
                        let checkX = player.x + Math.cos(rayDir) * checkDist;
                        let checkY = player.y + Math.sin(rayDir) * checkDist;
                        if (map[Math.floor(checkY)] && map[Math.floor(checkY)][Math.floor(checkX)] === 1) {
                            blocked = true;
                            break;
                        }
                        checkDist += 0.3;
                    }

                    if (blocked) return; // Skip this saw trap

                    let screenX = (0.5 * (sawAngle / (FOV / 2)) + 0.5) * WIDTH;
                    let sawSize = 60 / dist;
                    let rotationAngle = Date.now() / 50; // Fast spinning

                    // Draw rotating saw blade
                    ctx.save();
                    ctx.translate(screenX, HEIGHT / 2 + 20 / dist); // Position lower (floor level)

                    // Glow effect
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff4400';

                    // Outer ring
                    ctx.strokeStyle = '#aa3300';
                    ctx.lineWidth = sawSize / 8;
                    ctx.beginPath();
                    ctx.arc(0, 0, sawSize / 2, 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner metallic part
                    ctx.fillStyle = '#666666';
                    ctx.beginPath();
                    ctx.arc(0, 0, sawSize / 3, 0, Math.PI * 2);
                    ctx.fill();

                    // Saw teeth (rotating lines)
                    ctx.strokeStyle = '#ff6600';
                    ctx.lineWidth = 3;
                    for (let i = 0; i < 8; i++) {
                        let angle = rotationAngle + (i / 8) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * sawSize / 4, Math.sin(angle) * sawSize / 4);
                        ctx.lineTo(Math.cos(angle) * sawSize / 2, Math.sin(angle) * sawSize / 2);
                        ctx.stroke();
                    }

                    // Center bolt
                    ctx.fillStyle = '#333333';
                    ctx.beginPath();
                    ctx.arc(0, 0, sawSize / 8, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
            });

            // ===== RENDER MAGIC STAFF on screen =====
            renderStaff();

            if (screenShake > 0.1) {
                ctx.restore();
            }

            // ===== BLACKOUT EFFECT =====
            if (isBlackout) {
                let flickerAlpha = 0.92 + Math.random() * 0.08;
                ctx.fillStyle = `rgba(0, 0, 0, ${flickerAlpha})`;
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                // Occasional small flickers
                if (Math.random() < 0.08) {
                    ctx.fillStyle = 'rgba(30, 30, 50, 0.4)';
                    ctx.fillRect(0, 0, WIDTH, HEIGHT);
                }
            }

            // ===== RENDER MINIMAP =====
            if (showMinimap) {
                renderMinimap();
            }
        }

        // --- RENDER MAGIC STAFF (Enhanced Aesthetic Design) ---
        function renderStaff() {
            let staffX = WIDTH - 70;
            let staffY = HEIGHT - 10;
            let glowIntensity = staffGlow * 40;
            let time = Date.now() / 1000;

            ctx.save();

            // Draw different staff based on type
            switch (currentStaffType) {
                case 'electric':
                    renderElectricStaff(staffX, staffY, time);
                    break;
                case 'paper':
                    renderPaperStaff(staffX, staffY, time);
                    break;
                case 'electronic':
                    renderElectronicStaff(staffX, staffY, time);
                    break;
                default:
                    renderClassicStaff(staffX, staffY, time, glowIntensity);
            }

            ctx.restore();
        }

        // === CLASSIC PURPLE STAFF ===
        function renderClassicStaff(staffX, staffY, time, glowIntensity) {
            // === ORNATE WOODEN HANDLE ===
            // Main shaft with wood grain effect
            let gradient = ctx.createLinearGradient(staffX, staffY, staffX - 35, staffY - 120);
            gradient.addColorStop(0, '#8B4513');
            gradient.addColorStop(0.3, '#654321');
            gradient.addColorStop(0.5, '#8B4513');
            gradient.addColorStop(0.7, '#5D3A1A');
            gradient.addColorStop(1, '#4A2810');

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 10;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(staffX, staffY);
            ctx.quadraticCurveTo(staffX - 15, staffY - 60, staffX - 35, staffY - 120);
            ctx.stroke();

            // Wood grain details
            ctx.strokeStyle = 'rgba(40, 20, 10, 0.4)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                let offset = i * 25 + 20;
                ctx.moveTo(staffX - 3 - i * 3, staffY - offset);
                ctx.lineTo(staffX - 8 - i * 3, staffY - offset - 15);
                ctx.stroke();
            }

            // === GOLDEN RUNE BANDS ===
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 4;
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#FFD700';

            // Band 1
            ctx.beginPath();
            ctx.arc(staffX - 12, staffY - 40, 6, 0, Math.PI);
            ctx.stroke();

            // Band 2 with rune
            ctx.beginPath();
            ctx.arc(staffX - 22, staffY - 75, 7, 0, Math.PI);
            ctx.stroke();

            // Rune symbol
            ctx.font = '10px serif';
            ctx.fillStyle = '#FFD700';
            ctx.fillText('á›Ÿ', staffX - 26, staffY - 68);

            ctx.shadowBlur = 0;

            // === CRYSTAL HOLDER (Silver filigree) ===
            ctx.strokeStyle = '#C0C0C0';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(staffX - 30, staffY - 115);
            ctx.lineTo(staffX - 45, staffY - 130);
            ctx.lineTo(staffX - 35, staffY - 125);
            ctx.moveTo(staffX - 40, staffY - 115);
            ctx.lineTo(staffX - 25, staffY - 130);
            ctx.lineTo(staffX - 35, staffY - 125);
            ctx.stroke();

            // === 3D CRYSTAL ===
            let crystalX = staffX - 35;
            let crystalY = staffY - 150;
            let pulse = Math.sin(time * 3) * 0.15 + 1;

            // Crystal glow aura
            ctx.shadowBlur = 20 + glowIntensity;
            ctx.shadowColor = staffGlow > 0.1 ? '#FF00FF' : '#8800FF';

            // Crystal facets (3D effect)
            // Back facet (darker)
            ctx.fillStyle = staffGlow > 0.1 ? 'rgba(200, 50, 200, 0.9)' : 'rgba(80, 30, 120, 0.9)';
            ctx.beginPath();
            ctx.moveTo(crystalX, crystalY + 25 * pulse);
            ctx.lineTo(crystalX - 12 * pulse, crystalY);
            ctx.lineTo(crystalX, crystalY - 30 * pulse);
            ctx.lineTo(crystalX + 5, crystalY);
            ctx.closePath();
            ctx.fill();

            // Front facet (brighter)
            ctx.fillStyle = staffGlow > 0.1 ? 'rgba(255, 100, 255, 0.95)' : 'rgba(120, 60, 180, 0.95)';
            ctx.beginPath();
            ctx.moveTo(crystalX, crystalY + 25 * pulse);
            ctx.lineTo(crystalX + 5, crystalY);
            ctx.lineTo(crystalX, crystalY - 30 * pulse);
            ctx.lineTo(crystalX + 12 * pulse, crystalY);
            ctx.closePath();
            ctx.fill();

            // Highlight facet
            ctx.fillStyle = 'rgba(255, 200, 255, 0.6)';
            ctx.beginPath();
            ctx.moveTo(crystalX - 5, crystalY - 10);
            ctx.lineTo(crystalX, crystalY - 25 * pulse);
            ctx.lineTo(crystalX + 5, crystalY - 10);
            ctx.closePath();
            ctx.fill();

            // Inner core glow
            let coreGradient = ctx.createRadialGradient(crystalX, crystalY - 5, 0, crystalX, crystalY - 5, 15);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            coreGradient.addColorStop(0.5, staffGlow > 0.1 ? 'rgba(255, 150, 255, 0.6)' : 'rgba(150, 100, 200, 0.6)');
            coreGradient.addColorStop(1, 'rgba(100, 50, 150, 0)');
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(crystalX, crystalY - 5, 12 + staffGlow * 8, 0, Math.PI * 2);
            ctx.fill();

            // Sparkle effects
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            for (let i = 0; i < 3; i++) {
                let sparkleAngle = time * 2 + i * 2.1;
                let sparkleX = crystalX + Math.cos(sparkleAngle) * 8;
                let sparkleY = crystalY - 5 + Math.sin(sparkleAngle) * 8;
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.shadowBlur = 0;

            // === COOLDOWN INDICATOR (Arc style) ===
            if (staffCooldown > 0) {
                let cdPercent = staffCooldown / STAFF_COOLDOWN_TIME;
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.5)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(crystalX, crystalY - 5, 20, 0, Math.PI * 2);
                ctx.stroke();

                ctx.strokeStyle = '#FF00FF';
                ctx.beginPath();
                ctx.arc(crystalX, crystalY - 5, 20, -Math.PI / 2, -Math.PI / 2 + (1 - cdPercent) * Math.PI * 2);
                ctx.stroke();
            }
        }

        // === ELECTRIC CABLE STAFF ===
        function renderElectricStaff(staffX, staffY, time) {
            // === MAIN CABLE (Black) ===
            ctx.strokeStyle = '#222222';
            ctx.lineWidth = 12;
            ctx.lineCap = 'round';
            ctx.beginPath();
            // Wavy cable shape
            let wave = Math.sin(time * 5) * 5;
            ctx.moveTo(staffX, staffY);
            ctx.bezierCurveTo(staffX - 20 + wave, staffY - 50, staffX + 10 - wave, staffY - 100, staffX, staffY - 150);
            ctx.stroke();

            // === EXPOSED WIRES AT BASE ===
            ['#dd0000', '#00dd00', '#0000dd'].forEach((c, i) => {
                ctx.strokeStyle = c;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(staffX + 10 + i * 5, staffY);
                ctx.quadraticCurveTo(staffX + 5, staffY - 40, staffX, staffY - 80);
                ctx.stroke();
            });

            // === SPARKS AT TIP ===
            let tipX = staffX;
            let tipY = staffY - 150;

            // Core
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ffff00';
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(tipX, tipY, 8 + Math.random() * 4, 0, Math.PI * 2);
            ctx.fill();

            // Lightning bolts
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(tipX, tipY);
                let angle = Date.now() / 200 + i * (Math.PI * 2 / 3);
                let len = 30 + Math.random() * 20;
                ctx.lineTo(tipX + Math.cos(angle) * len, tipY + Math.sin(angle) * len);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;
        }

        // === TOILET PAPER STAFF ===
        function renderPaperStaff(staffX, staffY, time) {
            // Cardboard tube
            let gradient = ctx.createLinearGradient(staffX, staffY, staffX - 30, staffY - 100);
            gradient.addColorStop(0, '#8B7355');
            gradient.addColorStop(0.5, '#A0826D');
            gradient.addColorStop(1, '#6B5344');

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 14;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(staffX, staffY);
            ctx.lineTo(staffX - 30, staffY - 100);
            ctx.stroke();

            // Tube hole
            ctx.fillStyle = '#3D2817';
            ctx.beginPath();
            ctx.ellipse(staffX - 30, staffY - 100, 6, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Paper roll at top (unrolling animation)
            let unroll = Math.sin(time * 2) * 0.2 + 1;
            ctx.fillStyle = '#F5F5F5';
            ctx.strokeStyle = '#E0E0E0';
            ctx.lineWidth = 1;

            // Main roll
            ctx.beginPath();
            ctx.ellipse(staffX - 35, staffY - 130, 12 * unroll, 18 * unroll, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Paper texture lines
            ctx.strokeStyle = '#D0D0D0';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.arc(staffX - 35, staffY - 130, 5 + i * 3, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Trailing paper (flowing effect when casting)
            if (staffGlow > 0.1) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                for (let i = 0; i < 8; i++) {
                    let px = staffX - 35 + Math.sin(time * 5 + i) * (10 + i * 3);
                    let py = staffY - 130 + i * 8;
                    ctx.fillRect(px - 8, py, 16, 3);
                }
            }

            // Glow effect
            ctx.shadowBlur = 10 + staffGlow * 15;
            ctx.shadowColor = '#FFFFFF';
            ctx.fillStyle = staffGlow > 0.1 ? 'rgba(255, 255, 255, 0.9)' : 'rgba(240, 240, 240, 0.6)';
            ctx.beginPath();
            ctx.arc(staffX - 35, staffY - 130, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Cooldown
            if (staffCooldown > 0) {
                let cdPercent = staffCooldown / STAFF_COOLDOWN_TIME;
                ctx.strokeStyle = '#AAAAAA';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(staffX - 35, staffY - 130, 22, -Math.PI / 2, -Math.PI / 2 + (1 - cdPercent) * Math.PI * 2);
                ctx.stroke();
            }
        }

        // === ELECTRONIC COMPONENT STAFF ===
        function renderElectronicStaff(staffX, staffY, time) {
            // PCB-style handle (green circuit board)
            let gradient = ctx.createLinearGradient(staffX, staffY, staffX - 35, staffY - 120);
            gradient.addColorStop(0, '#1A5F1A');
            gradient.addColorStop(0.5, '#2D8B2D');
            gradient.addColorStop(1, '#1A5F1A');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(staffX + 5, staffY);
            ctx.lineTo(staffX - 5, staffY);
            ctx.lineTo(staffX - 40, staffY - 120);
            ctx.lineTo(staffX - 30, staffY - 120);
            ctx.closePath();
            ctx.fill();

            // Circuit traces
            ctx.strokeStyle = '#C0C0C0';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                let yOff = i * 25 + 20;
                ctx.moveTo(staffX - 2 - i * 3, staffY - yOff);
                ctx.lineTo(staffX - 2 - i * 3, staffY - yOff - 10);
                ctx.lineTo(staffX - 8 - i * 3, staffY - yOff - 10);
                ctx.stroke();
            }

            // Transistor body at top (TO-220 package style)
            ctx.fillStyle = '#333333';
            ctx.fillRect(staffX - 50, staffY - 150, 30, 25);

            // Metal tab
            ctx.fillStyle = '#888888';
            ctx.fillRect(staffX - 50, staffY - 155, 30, 8);

            // Transistor text
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '6px monospace';
            ctx.fillText('2N2222', staffX - 48, staffY - 137);

            // Three pins
            ctx.fillStyle = '#C0C0C0';
            for (let i = 0; i < 3; i++) {
                ctx.fillRect(staffX - 45 + i * 10, staffY - 125, 3, 20);
            }

            // LED indicator
            let ledGlow = Math.sin(time * 6) * 0.5 + 0.5;
            ctx.shadowBlur = 15 + staffGlow * 20;
            ctx.shadowColor = staffGlow > 0.1 ? '#00FF00' : '#00AA00';
            ctx.fillStyle = staffGlow > 0.1 ? `rgba(0, 255, 0, ${0.7 + ledGlow * 0.3})` : `rgba(0, 170, 0, ${0.5 + ledGlow * 0.3})`;
            ctx.beginPath();
            ctx.arc(staffX - 35, staffY - 165, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Capacitor near base
            ctx.fillStyle = '#0066CC';
            ctx.fillRect(staffX - 8, staffY - 60, 8, 15);
            ctx.fillStyle = '#888888';
            ctx.fillRect(staffX - 8, staffY - 60, 8, 3);

            // Resistor bands
            ctx.fillStyle = '#D2B48C';
            ctx.fillRect(staffX - 15, staffY - 35, 12, 6);
            ['#A52A2A', '#FF0000', '#FFA500', '#FFD700'].forEach((c, i) => {
                ctx.fillStyle = c;
                ctx.fillRect(staffX - 14 + i * 3, staffY - 35, 2, 6);
            });

            // Cooldown (digital style)
            if (staffCooldown > 0) {
                let cdPercent = staffCooldown / STAFF_COOLDOWN_TIME;
                ctx.strokeStyle = '#00FF00';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(staffX - 35, staffY - 140, 25, -Math.PI / 2, -Math.PI / 2 + (1 - cdPercent) * Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // === STAFF PREVIEW FUNCTIONS ===
        function drawAllStaffPreviews() {
            drawStaffPreview('preview-classic', 'classic');
            drawStaffPreview('preview-electric', 'electric');
            drawStaffPreview('preview-paper', 'paper');
            drawStaffPreview('preview-electronic', 'electronic');
        }

        function drawStaffPreview(canvasId, staffType) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const pctx = canvas.getContext('2d');
            pctx.clearRect(0, 0, 80, 80);

            // Arka plan
            pctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            pctx.fillRect(0, 0, 80, 80);

            const cx = 40, cy = 45;

            switch (staffType) {
                case 'classic':
                    // Mor kristal asa
                    pctx.strokeStyle = '#8B4513';
                    pctx.lineWidth = 4;
                    pctx.lineCap = 'round';
                    pctx.beginPath();
                    pctx.moveTo(cx + 15, cy + 30);
                    pctx.quadraticCurveTo(cx + 5, cy, cx, cy - 25);
                    pctx.stroke();
                    // Kristal
                    pctx.shadowBlur = 10;
                    pctx.shadowColor = '#ff00ff';
                    pctx.fillStyle = '#aa44aa';
                    pctx.beginPath();
                    pctx.moveTo(cx, cy - 35);
                    pctx.lineTo(cx - 8, cy - 20);
                    pctx.lineTo(cx, cy - 10);
                    pctx.lineTo(cx + 8, cy - 20);
                    pctx.closePath();
                    pctx.fill();
                    pctx.shadowBlur = 0;
                    break;

                case 'electric':
                    // Elektrik kablosu
                    pctx.strokeStyle = '#222222';
                    pctx.lineWidth = 5;
                    pctx.lineCap = 'round';
                    pctx.beginPath();
                    pctx.moveTo(cx + 15, cy + 30);
                    pctx.bezierCurveTo(cx + 10, cy + 10, cx - 5, cy - 10, cx, cy - 25);
                    pctx.stroke();
                    // Renkli kablolar
                    ['#ff0000', '#00ff00', '#0000ff'].forEach((c, i) => {
                        pctx.strokeStyle = c;
                        pctx.lineWidth = 1.5;
                        pctx.beginPath();
                        pctx.moveTo(cx + 13 + (i - 1) * 2, cy + 28);
                        pctx.lineTo(cx - 2 + (i - 1) * 2, cy - 20);
                        pctx.stroke();
                    });
                    // Elektrik kÄ±vÄ±lcÄ±mÄ±
                    pctx.shadowBlur = 8;
                    pctx.shadowColor = '#ffff00';
                    pctx.fillStyle = '#ffff00';
                    pctx.beginPath();
                    pctx.arc(cx, cy - 28, 6, 0, Math.PI * 2);
                    pctx.fill();
                    pctx.shadowBlur = 0;
                    break;

                case 'paper':
                    // Tuvalet kaÄŸÄ±dÄ±
                    pctx.strokeStyle = '#8B7355';
                    pctx.lineWidth = 5;
                    pctx.lineCap = 'round';
                    pctx.beginPath();
                    pctx.moveTo(cx + 15, cy + 30);
                    pctx.lineTo(cx, cy - 10);
                    pctx.stroke();
                    // KaÄŸÄ±t rulosu
                    pctx.fillStyle = '#F5F5F5';
                    pctx.strokeStyle = '#E0E0E0';
                    pctx.lineWidth = 1;
                    pctx.beginPath();
                    pctx.ellipse(cx - 3, cy - 20, 10, 15, 0, 0, Math.PI * 2);
                    pctx.fill();
                    pctx.stroke();
                    // Ã‡izgiler
                    pctx.strokeStyle = '#D0D0D0';
                    pctx.lineWidth = 0.5;
                    for (let i = 0; i < 3; i++) {
                        pctx.beginPath();
                        pctx.arc(cx - 3, cy - 20, 4 + i * 4, 0, Math.PI * 2);
                        pctx.stroke();
                    }
                    break;

                case 'electronic':
                    // Elektronik parÃ§a
                    pctx.fillStyle = '#1A5F1A';
                    pctx.beginPath();
                    pctx.moveTo(cx + 12, cy + 30);
                    pctx.lineTo(cx + 8, cy + 30);
                    pctx.lineTo(cx - 8, cy - 15);
                    pctx.lineTo(cx - 4, cy - 15);
                    pctx.closePath();
                    pctx.fill();
                    // TransistÃ¶r
                    pctx.fillStyle = '#333333';
                    pctx.fillRect(cx - 12, cy - 35, 20, 15);
                    pctx.fillStyle = '#888888';
                    pctx.fillRect(cx - 12, cy - 38, 20, 5);
                    // Pinler
                    pctx.fillStyle = '#C0C0C0';
                    for (let i = 0; i < 3; i++) {
                        pctx.fillRect(cx - 8 + i * 7, cy - 20, 2, 10);
                    }
                    // LED
                    pctx.shadowBlur = 6;
                    pctx.shadowColor = '#00ff00';
                    pctx.fillStyle = '#00ff00';
                    pctx.beginPath();
                    pctx.arc(cx - 2, cy - 42, 4, 0, Math.PI * 2);
                    pctx.fill();
                    pctx.shadowBlur = 0;
                    break;
            }
        }

        // --- RENDER MINIMAP (Bird's eye view) ---
        function renderMinimap() {
            // Clear minimap
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, MINIMAP_SIZE, MINIMAP_SIZE);

            // Draw blood splatters first (under everything)
            bloodSplatters.forEach(blood => {
                minimapCtx.fillStyle = `rgba(150, 0, 0, ${blood.opacity * 0.6})`;
                minimapCtx.beginPath();
                minimapCtx.arc(
                    blood.x * MINIMAP_SCALE,
                    blood.y * MINIMAP_SCALE,
                    blood.size * MINIMAP_SCALE,
                    0,
                    Math.PI * 2
                );
                minimapCtx.fill();
            });

            // Draw walls and special tiles
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    let block = map[y] ? map[y][x] : 1;
                    if (block === 1) {
                        minimapCtx.fillStyle = 'rgba(100, 100, 100, 0.8)';
                    } else if (block === 2) {
                        // Keys hidden on minimap - player must explore to find them
                        continue;
                    } else if (block === 3) {
                        // Exit door - green if active, gray if not
                        if (exitDoor.active) {
                            minimapCtx.fillStyle = 'rgba(0, 255, 100, 0.9)';
                        } else {
                            minimapCtx.fillStyle = 'rgba(100, 50, 50, 0.7)';
                        }
                    } else if (block === 5) {
                        // Sticky ground - dark brown/red
                        minimapCtx.fillStyle = 'rgba(80, 30, 20, 0.8)';
                    } else {
                        continue; // Don't draw empty
                    }
                    minimapCtx.fillRect(
                        x * MINIMAP_SCALE,
                        y * MINIMAP_SCALE,
                        MINIMAP_SCALE,
                        MINIMAP_SCALE
                    );
                }
            }

            // (Saw traps hidden on minimap for surprise factor)

            // (Enemies hidden on minimap for surprise factor)


            // Draw spell projectiles on minimap (color based on staff type)
            spellProjectiles.forEach(spell => {
                // Set color based on staff type
                switch (spell.staffType) {
                    case 'electric': minimapCtx.fillStyle = 'rgba(255, 255, 0, 0.9)'; break;
                    case 'paper': minimapCtx.fillStyle = 'rgba(255, 255, 255, 0.9)'; break;
                    case 'electronic': minimapCtx.fillStyle = 'rgba(0, 255, 0, 0.9)'; break;
                    default: minimapCtx.fillStyle = 'rgba(200, 100, 255, 0.9)';
                }
                minimapCtx.beginPath();
                minimapCtx.arc(
                    spell.x * MINIMAP_SCALE,
                    spell.y * MINIMAP_SCALE,
                    2,
                    0,
                    Math.PI * 2
                );
                minimapCtx.fill();
            });

            // Draw player on minimap
            minimapCtx.fillStyle = 'rgba(0, 255, 100, 1)';
            minimapCtx.beginPath();
            minimapCtx.arc(
                player.x * MINIMAP_SCALE,
                player.y * MINIMAP_SCALE,
                4,
                0,
                Math.PI * 2
            );
            minimapCtx.fill();

            // Draw player direction
            minimapCtx.strokeStyle = 'rgba(0, 255, 100, 0.8)';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(player.x * MINIMAP_SCALE, player.y * MINIMAP_SCALE);
            minimapCtx.lineTo(
                (player.x + Math.cos(player.dir) * 1.5) * MINIMAP_SCALE,
                (player.y + Math.sin(player.dir) * 1.5) * MINIMAP_SCALE
            );
            minimapCtx.stroke();

            // Draw FOV cone
            minimapCtx.strokeStyle = 'rgba(0, 255, 100, 0.3)';
            minimapCtx.lineWidth = 1;
            minimapCtx.beginPath();
            minimapCtx.moveTo(player.x * MINIMAP_SCALE, player.y * MINIMAP_SCALE);
            minimapCtx.lineTo(
                (player.x + Math.cos(player.dir - FOV / 2) * 3) * MINIMAP_SCALE,
                (player.y + Math.sin(player.dir - FOV / 2) * 3) * MINIMAP_SCALE
            );
            minimapCtx.moveTo(player.x * MINIMAP_SCALE, player.y * MINIMAP_SCALE);
            minimapCtx.lineTo(
                (player.x + Math.cos(player.dir + FOV / 2) * 3) * MINIMAP_SCALE,
                (player.y + Math.sin(player.dir + FOV / 2) * 3) * MINIMAP_SCALE
            );
            minimapCtx.stroke();
        }

        function playSound(type, enemyType) {
            if (!audioCtx) return;

            if (type === 'pickup') {
                // Dark metallic clang - like finding something in a horror basement
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.3);
                g.gain.setValueAtTime(0.3, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.4);
                osc.connect(g).connect(masterGainNode);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.4);

                // Radiator clunk
                const osc2 = audioCtx.createOscillator();
                const g2 = audioCtx.createGain();
                osc2.type = 'square';
                osc2.frequency.setValueAtTime(30, audioCtx.currentTime);
                g2.gain.setValueAtTime(0.2, audioCtx.currentTime);
                g2.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
                osc2.connect(g2).connect(masterGainNode);
                osc2.start();
                osc2.stop(audioCtx.currentTime + 0.2);

            } else if (type === 'glitch') {
                // Terrifying static screech
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sawtooth';
                for (let i = 0; i < 10; i++) {
                    osc.frequency.setValueAtTime(50 + Math.random() * 200, audioCtx.currentTime + i * 0.02);
                }
                g.gain.setValueAtTime(0.4, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.connect(g).connect(masterGainNode);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);

            } else if (type === 'spell_cast') {
                // Deep industrial boom
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(60, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.15);
                g.gain.setValueAtTime(0.35, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.25);
                osc.connect(g).connect(masterGainNode);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.25);

            } else if (type === 'enemy_scream') {
                // TERRIFYING DEEP SCREAM - Industrial horror
                // Layer 1: Deep growl
                const osc1 = audioCtx.createOscillator();
                const g1 = audioCtx.createGain();
                osc1.type = 'sawtooth';
                osc1.frequency.setValueAtTime(40, audioCtx.currentTime);
                osc1.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.1);
                osc1.frequency.exponentialRampToValueAtTime(25, audioCtx.currentTime + 0.5);
                g1.gain.setValueAtTime(0.5, audioCtx.currentTime);
                g1.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.6);
                osc1.connect(g1).connect(masterGainNode);
                osc1.start();
                osc1.stop(audioCtx.currentTime + 0.6);

                // Layer 2: Radiator rattle
                const osc2 = audioCtx.createOscillator();
                const g2 = audioCtx.createGain();
                osc2.type = 'square';
                osc2.frequency.setValueAtTime(20, audioCtx.currentTime);
                for (let i = 0; i < 5; i++) {
                    osc2.frequency.setValueAtTime(15 + Math.random() * 10, audioCtx.currentTime + i * 0.08);
                }
                g2.gain.setValueAtTime(0.25, audioCtx.currentTime);
                g2.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.4);
                osc2.connect(g2).connect(masterGainNode);
                osc2.start();
                osc2.stop(audioCtx.currentTime + 0.4);

            } else if (type === 'enemy_death') {
                // DEATH SCREAM - Long agonizing industrial horror
                // Deep dying roar
                const osc1 = audioCtx.createOscillator();
                const g1 = audioCtx.createGain();
                osc1.type = 'sawtooth';
                osc1.frequency.setValueAtTime(60, audioCtx.currentTime);
                osc1.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 1.2);
                g1.gain.setValueAtTime(0.6, audioCtx.currentTime);
                g1.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.5);
                osc1.connect(g1).connect(masterGainNode);
                osc1.start();
                osc1.stop(audioCtx.currentTime + 1.5);

                // Metallic screech
                const osc2 = audioCtx.createOscillator();
                const g2 = audioCtx.createGain();
                osc2.type = 'sawtooth';
                osc2.frequency.setValueAtTime(100, audioCtx.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.8);
                g2.gain.setValueAtTime(0.35, audioCtx.currentTime);
                g2.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.0);
                osc2.connect(g2).connect(masterGainNode);
                osc2.start();
                osc2.stop(audioCtx.currentTime + 1.0);

                // Radiator death rattle
                for (let i = 0; i < 6; i++) {
                    const o = audioCtx.createOscillator();
                    const gg = audioCtx.createGain();
                    o.type = 'square';
                    o.frequency.setValueAtTime(15 + Math.random() * 15, audioCtx.currentTime + i * 0.15);
                    gg.gain.setValueAtTime(0.2, audioCtx.currentTime + i * 0.15);
                    gg.gain.linearRampToValueAtTime(0, audioCtx.currentTime + i * 0.15 + 0.1);
                    o.connect(gg).connect(masterGainNode);
                    o.start(audioCtx.currentTime + i * 0.15);
                    o.stop(audioCtx.currentTime + i * 0.15 + 0.15);
                }

            } else if (type === 'exhausted') {
                // Heavy breathing / gasping sound
                for (let i = 0; i < 3; i++) {
                    const osc = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(80 + i * 20, audioCtx.currentTime + i * 0.15);
                    osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + i * 0.15 + 0.1);
                    g.gain.setValueAtTime(0.15, audioCtx.currentTime + i * 0.15);
                    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + i * 0.15 + 0.15);
                    osc.connect(g).connect(masterGainNode);
                    osc.start(audioCtx.currentTime + i * 0.15);
                    osc.stop(audioCtx.currentTime + i * 0.15 + 0.2);
                }

            } else if (type === 'saw_hit') {
                // Grinding metal saw sound
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(150, audioCtx.currentTime + 0.05);
                osc.frequency.linearRampToValueAtTime(250, audioCtx.currentTime + 0.1);
                g.gain.setValueAtTime(0.3, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.15);
                osc.connect(g).connect(masterGainNode);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);

                // Metal scrape
                const osc2 = audioCtx.createOscillator();
                const g2 = audioCtx.createGain();
                osc2.type = 'square';
                osc2.frequency.setValueAtTime(100, audioCtx.currentTime);
                g2.gain.setValueAtTime(0.15, audioCtx.currentTime);
                g2.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc2.connect(g2).connect(masterGainNode);
                osc2.start();
                osc2.stop(audioCtx.currentTime + 0.1);

            } else if (type === 'power_out') {
                // Electrical buzz and pop for power outage
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(60, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(30, audioCtx.currentTime + 0.1);
                g.gain.setValueAtTime(0.25, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.15);
                osc.connect(g).connect(masterGainNode);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);

                // Electric crackle
                const noise = audioCtx.createOscillator();
                const ng = audioCtx.createGain();
                noise.type = 'square';
                noise.frequency.setValueAtTime(2000, audioCtx.currentTime);
                noise.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                ng.gain.setValueAtTime(0.1, audioCtx.currentTime);
                ng.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                noise.connect(ng).connect(masterGainNode);
                noise.start();
                noise.stop(audioCtx.currentTime + 0.1);

            } else if (type === 'web_shot') {
                // Wet splat sound for spider web
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.15);
                g.gain.setValueAtTime(0.2, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
                osc.connect(g).connect(masterGainNode);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            }
        }

        // --- VICTORY SCREEN ---
        function victory() {
            running = false;
            gameWon = true;
            document.exitPointerLock();

            // Calculate and save completion time
            let completionTime = (Date.now() - gameStartTime) / 1000;
            saveScore(completionTime);
            let mins = Math.floor(completionTime / 60);
            let secs = Math.floor(completionTime % 60);
            let timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;

            // Victory screen
            ctx.fillStyle = "rgba(0, 20, 0, 0.95)";
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Green glow effect
            let gradient = ctx.createRadialGradient(WIDTH / 2, HEIGHT / 2, 0, WIDTH / 2, HEIGHT / 2, 200);
            gradient.addColorStop(0, 'rgba(0, 100, 50, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            ctx.fillStyle = "#00FF88";
            ctx.font = "32px Courier";
            ctx.textAlign = "center";
            ctx.shadowBlur = 20;
            ctx.shadowColor = "#00FF88";
            ctx.fillText("AYAZAÄžADAN KAÃ‡TINIZ!", WIDTH / 2, HEIGHT / 2 - 50);

            // Show completion time
            ctx.font = "18px Courier";
            ctx.fillStyle = "#ffcc00";
            ctx.shadowColor = "#ffcc00";
            ctx.fillText(`â±ï¸ SÃ¼re: ${timeStr}`, WIDTH / 2, HEIGHT / 2 - 15);

            ctx.shadowBlur = 0;
            ctx.font = "12px Courier";
            ctx.fillStyle = "#66FFAA";
            ctx.fillText("Ehabeliler elbet bir gÃ¼n gÃ¶tÃ¼nÃ¼zÃ¼ sikecektir", WIDTH / 2, HEIGHT / 2 + 15);
            ctx.fillText("ancak ÅŸimdilik kurtuldunuz.", WIDTH / 2, HEIGHT / 2 + 35);

            ctx.fillStyle = "#888";
            ctx.font = "10px Courier";
            const diffNames = { easy: 'KOLAY', normal: 'ORTA', hard: 'ZOR' };
            ctx.fillText(`Zorluk: ${diffNames[difficulty]} | Skor kaydedildi!`, WIDTH / 2, HEIGHT / 2 + 55);

            ctx.fillStyle = "#fff";
            ctx.font = "14px Courier";
            ctx.fillText("[ TEKRAR OYNAMAK Ä°Ã‡Ä°N TIKLA ]", WIDTH / 2, HEIGHT / 2 + 85);

            if (ambianceNode) ambianceNode.stop();
            if (staticNoiseNode) staticNoiseNode.stop();

            // Play victory sound
            if (audioCtx) {
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.2);
                osc.frequency.setValueAtTime(600, audioCtx.currentTime + 0.3);
                osc.frequency.exponentialRampToValueAtTime(1000, audioCtx.currentTime + 0.5);
                g.gain.setValueAtTime(0.3, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.8);
                osc.connect(g).connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.8);
            }

            setTimeout(() => {
                document.addEventListener('mousedown', () => location.reload(), { once: true });
            }, 500);
        }

        function gameOver(killer) {
            running = false;
            document.exitPointerLock();

            // Clear screen to black
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Red vignette
            let gradient = ctx.createRadialGradient(WIDTH / 2, HEIGHT / 2, 0, WIDTH / 2, HEIGHT / 2, 250);
            gradient.addColorStop(0, 'rgba(50, 0, 0, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Turkish death message
            let deathMsg = "EHABELÄ°LERE YAKALANDINIZ";
            let subMsg = "MÃ¼hfak acÄ±maz.";

            if (killer === 'insanity') {
                deathMsg = "AKLIN KIRILDI";
                subMsg = "Zihin parÃ§alandÄ±...";
            }

            // Glow effect
            ctx.shadowBlur = 20;
            ctx.shadowColor = "red";
            ctx.fillStyle = "#FF0000";
            ctx.font = "bold 28px Courier";
            ctx.textAlign = "center";
            ctx.fillText(deathMsg, WIDTH / 2, HEIGHT / 2);

            ctx.shadowBlur = 0;
            ctx.font = "16px Courier";
            ctx.fillStyle = "#888";
            ctx.fillText(subMsg, WIDTH / 2, HEIGHT / 2 + 35);

            ctx.fillStyle = "#fff";
            ctx.fillText("[ TEKRAR OYNAMAK Ä°Ã‡Ä°N TIKLA ]", WIDTH / 2, HEIGHT / 2 + 70);

            if (ambianceNode) ambianceNode.stop();

            // Add restart functionality
            // Use 'mousedown' on document to ensure we catch it even if pointer lock state is weird
            setTimeout(() => {
                document.addEventListener('mousedown', () => location.reload(), { once: true });
            }, 500); // Small delay to prevent instant restart if clicking while dying
        }

        init();

    </script>
</body>

</html>