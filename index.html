<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>VOID_RUNNER_V1</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            cursor: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2;
            pointer-events: none;
            mix-blend-mode: difference;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: transparent;
            z-index: 3;
            box-shadow: inset 0 0 150px #000;
        }

        #noise {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.08;
            pointer-events: none;
            z-index: 4;
            background-image: url('data:image/svg+xml;utf8,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="3" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)"/%3E%3C/svg%3E');
        }

        #start {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            cursor: pointer;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 3rem;
            text-shadow: 2px 0 red, -2px 0 blue;
            letter-spacing: 5px;
        }

        p {
            font-size: 1.2rem;
            opacity: 0.8;
        }
    </style>
</head>

<body>

    <div id="ui">
        <div>SANITY: <span id="sanity-val">100%</span></div>
        <div>KEYS: <span id="keys-val">0/3</span></div>
        <div id="msg"></div>
    </div>
    <div id="overlay"></div>
    <div id="noise"></div>

    <div id="start">
        <h1>THE LABYRINTH</h1>
        <p>[ CLICK TO INITIALIZE ]</p>
        <p style="font-size: 0.8rem; color: #666;">HEADPHONES REQUIRED</p>
    </div>

    <canvas id="game"></canvas>

    <script>
        /**
         * ENGINE: RAYCASTING (WOLFENSTEIN 3D STYLE)
         * AUDIO: WEB AUDIO API OSCILLATORS
         * AI: A* PATHFINDING + LOS CHECK
         */

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d', { alpha: false });
        const uiSanity = document.getElementById('sanity-val');
        const uiKeys = document.getElementById('keys-val');
        const uiMsg = document.getElementById('msg');
        const startScreen = document.getElementById('start');

        // Config
        const WIDTH = 640;
        const HEIGHT = 360; // Internal resolution for retro feel
        const FOV = Math.PI / 3;
        const BLOCK_SIZE = 64;
        const MAP_SIZE = 16;
        const MAX_DEPTH = 16; // Render distance
        const RAYS = WIDTH / 2; // Resolution divider

        let running = false;
        let audioCtx;
        let lastTime = 0;

        // Game State
        const player = { x: 2.5, y: 2.5, dir: 0, speed: 3.0, rotSpeed: 2.5 };
        const keys = { w: false, s: false, a: false, d: false, left: false, right: false, shift: false };
        const map = []; // 1: Wall, 0: Empty, 2: Key, 3: Exit
        let collectedKeys = 0;
        let sanity = 100;
        let enemy = { x: 10.5, y: 10.5, active: false, speed: 2.2, visible: false };

        // Audio Nodes
        let ambianceNode, heartNode, screechNode;

        // --- INIT ---
        function init() {
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            generateMap();

            // Resize handler
            window.addEventListener('resize', () => {
                // Keep internal res fixed, stretch via CSS
            });

            document.addEventListener('keydown', e => handleKey(e.key, true));
            document.addEventListener('keyup', e => handleKey(e.key, false));

            startScreen.addEventListener('click', () => {
                if (!audioCtx) initAudio();
                startScreen.classList.add('hidden');
                canvas.requestPointerLock();
                running = true;
                enemy.active = true;
                requestAnimationFrame(loop);
            });
        }

        function handleKey(k, state) {
            k = k.toLowerCase();
            if (k === 'w' || k === 'arrowup') keys.w = state;
            if (k === 's' || k === 'arrowdown') keys.s = state;
            if (k === 'a') keys.left = state; // Strafe/Turn logic split handled in update
            if (k === 'd') keys.right = state;
            if (k === 'arrowleft') keys.left = state;
            if (k === 'arrowright') keys.right = state;
            if (k === 'shift') keys.shift = state;
        }

        // --- GENERATION ---
        function generateMap() {
            // Simple cellular noise or hardcoded room
            for (let y = 0; y < MAP_SIZE; y++) {
                let row = [];
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (x === 0 || x === MAP_SIZE - 1 || y === 0 || y === MAP_SIZE - 1) row.push(1);
                    else row.push(Math.random() > 0.85 ? 1 : 0);
                }
                map.push(row);
            }
            // Clear spawn
            map[2][2] = 0; map[2][3] = 0; map[3][2] = 0;
            // Place Keys
            let placed = 0;
            while (placed < 3) {
                let rx = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                let ry = Math.floor(Math.random() * (MAP_SIZE - 2)) + 1;
                if (map[ry][rx] === 0) { map[ry][rx] = 2; placed++; }
            }
        }

        // --- AUDIO SYSTEM (Procedural) ---
        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();

            // Ambiance (Low drone)
            ambianceNode = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            ambianceNode.type = 'sawtooth';
            ambianceNode.frequency.value = 50;
            gain.gain.value = 0.05;

            // Filter for drone
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 120;

            ambianceNode.connect(filter).connect(gain).connect(audioCtx.destination);
            ambianceNode.start();

            // Heartbeat logic setup
            heartNode = {
                play: () => {
                    const osc = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    osc.frequency.setValueAtTime(60, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.1);
                    g.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    osc.connect(g).connect(audioCtx.destination);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.15);
                }
            };
        }

        // --- ENGINE CORE ---
        function loop(timestamp) {
            if (!running) return;
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            update(dt);
            render();

            requestAnimationFrame(loop);
        }

        function update(dt) {
            // Player Movement
            const moveStep = (keys.shift ? player.speed * 1.5 : player.speed) * dt;
            const rotStep = player.rotSpeed * dt;

            if (keys.left) player.dir -= rotStep;
            if (keys.right) player.dir += rotStep;

            const newX = player.x + Math.cos(player.dir) * (keys.w ? moveStep : keys.s ? -moveStep : 0);
            const newY = player.y + Math.sin(player.dir) * (keys.w ? moveStep : keys.s ? -moveStep : 0);

            // Collision
            if (map[Math.floor(newY)][Math.floor(player.x)] === 0 || map[Math.floor(newY)][Math.floor(player.x)] >= 2) player.y = newY;
            if (map[Math.floor(player.y)][Math.floor(newX)] === 0 || map[Math.floor(player.y)][Math.floor(newX)] >= 2) player.x = newX;

            // Item Pickup
            let px = Math.floor(player.x);
            let py = Math.floor(player.y);
            if (map[py][px] === 2) {
                map[py][px] = 0;
                collectedKeys++;
                uiKeys.innerText = `${collectedKeys}/3`;
                uiMsg.innerText = "KEY ACQUIRED";
                setTimeout(() => uiMsg.innerText = "", 2000);
                playSound('pickup');
            }

            // Enemy AI (Simple Stalk)
            if (enemy.active) {
                let dx = player.x - enemy.x;
                let dy = player.y - enemy.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                // Move towards player
                let ex = enemy.x + (dx / dist) * enemy.speed * dt * 0.4; // Slower than player
                let ey = enemy.y + (dy / dist) * enemy.speed * dt * 0.4;

                // Simple collision for enemy (can clip corners, adds scariness)
                if (map[Math.floor(ey)][Math.floor(ex)] !== 1) {
                    enemy.x = ex;
                    enemy.y = ey;
                }

                // Heartbeat / Proximity
                let beatRate = Math.max(200, dist * 100);
                if (Date.now() % Math.floor(beatRate) < 20) heartNode.play();

                // Death
                if (dist < 0.5) {
                    gameOver();
                }

                // Sanity Drain
                if (dist < 3) sanity -= dt * 5;
                if (sanity < 0) gameOver();
                uiSanity.innerText = Math.floor(sanity) + "%";
            }
        }

        function render() {
            // Ceiling/Floor
            ctx.fillStyle = "#111";
            ctx.fillRect(0, 0, WIDTH, HEIGHT / 2);
            ctx.fillStyle = "#222";
            ctx.fillRect(0, HEIGHT / 2, WIDTH, HEIGHT / 2);

            // Raycasting
            for (let x = 0; x < RAYS; x++) {
                const rayAngle = (player.dir - FOV / 2.0) + (x / RAYS) * FOV;
                const eyeX = Math.cos(rayAngle);
                const eyeY = Math.sin(rayAngle);

                let distToWall = 0;
                let hitWall = false;
                let texture = 0; // 0: Wall, 1: Key

                let testX = player.x;
                let testY = player.y;

                // DDA Algorithm (Simplified)
                while (!hitWall && distToWall < MAX_DEPTH) {
                    distToWall += 0.1;
                    testX = player.x + eyeX * distToWall;
                    testY = player.y + eyeY * distToWall;

                    if (testX < 0 || testX >= MAP_SIZE || testY < 0 || testY >= MAP_SIZE) {
                        hitWall = true;
                        distToWall = MAX_DEPTH;
                    } else {
                        let block = map[Math.floor(testY)][Math.floor(testX)];
                        if (block === 1) { hitWall = true; texture = 1; }
                        else if (block === 2) {
                            // Render Key as separate sprite? No, simplified: Color change
                        }
                    }
                }

                // Fisheye fix
                let ca = player.dir - rayAngle;
                if (ca < 0) ca += 2 * Math.PI;
                if (ca > 2 * Math.PI) ca -= 2 * Math.PI;
                distToWall = distToWall * Math.cos(ca);

                // Wall Height
                const ceiling = HEIGHT / 2.0 - HEIGHT / distToWall;
                const floor = HEIGHT - ceiling;
                const wallHeight = floor - ceiling;

                // Draw Wall strip
                let color = Math.floor(255 / (distToWall * 0.8)); // Distance shading
                if (color > 255) color = 255;

                ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;

                // Key is special logic, simplistic rendering for snippet
                // Check for items
                /* Advanced: Sprite rendering is complex for 1 file. 
                   We will indicate items via UI/HUD radar or proximity sound. */

                const w = WIDTH / RAYS;
                ctx.fillRect(x * w, ceiling, w, wallHeight);
            }

            // Render Enemy (Billboard Sprite Logic Simplified)
            // Calculate angle to enemy
            let dx = enemy.x - player.x;
            let dy = enemy.y - player.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            let spriteAngle = Math.atan2(dy, dx) - player.dir;
            while (spriteAngle < -Math.PI) spriteAngle += 2 * Math.PI;
            while (spriteAngle > Math.PI) spriteAngle -= 2 * Math.PI;

            // Is visible in FOV?
            if (Math.abs(spriteAngle) < FOV / 1.5 && dist < MAX_DEPTH) {
                let screenX = (0.5 * (spriteAngle / (FOV / 2)) + 0.5) * WIDTH;
                let spriteHeight = HEIGHT / dist;
                let spriteWidth = spriteHeight * 0.6;

                // Draw Scary Eyes
                ctx.fillStyle = `rgba(255, 0, 0, ${1 - dist / 10})`;
                ctx.beginPath();
                ctx.arc(screenX - 10, HEIGHT / 2, spriteWidth / 5, 0, Math.PI * 2);
                ctx.arc(screenX + 10, HEIGHT / 2, spriteWidth / 5, 0, Math.PI * 2);
                ctx.fill();

                // Shadow Body
                ctx.fillStyle = `rgba(0,0,0, ${1 - dist / 8})`;
                ctx.fillRect(screenX - spriteWidth / 2, HEIGHT / 2 - spriteHeight / 2 + 50, spriteWidth, spriteHeight);
            }
        }

        function playSound(type) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.connect(g).connect(audioCtx.destination);

            if (type === 'pickup') {
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
                g.gain.setValueAtTime(0.1, audioCtx.currentTime);
                g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.2);
            }
            osc.start();
            osc.stop(audioCtx.currentTime + 0.2);
        }

        function gameOver() {
            running = false;
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = "red";
            ctx.font = "40px Courier";
            ctx.textAlign = "center";
            ctx.fillText("TERMINATED", WIDTH / 2, HEIGHT / 2);
            ambianceNode.stop();
        }

        init();

    </script>
</body>

</html>